{"ast":null,"code":"import * as React from 'react';\nimport classnames from 'classnames';\nimport { createAction, createReducer } from '@reduxjs/toolkit';\nimport { extractLabel, columnIndexToLabel, Parser } from 'hot-formula-parser';\nimport { createContext, useContextSelector } from 'use-context-selector';\nimport flatMap from 'array.prototype.flatmap';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __generator(thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n}\nfunction __spreadArray(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n}\n\n/**\r\n * Interface for ranges between two points\r\n */\n/** Creates a normalized range between two given points */\nfunction create(source, target) {\n  return {\n    start: {\n      row: Math.min(source.row, target.row),\n      column: Math.min(source.column, target.column)\n    },\n    end: {\n      row: Math.max(source.row, target.row),\n      column: Math.max(source.column, target.column)\n    }\n  };\n}\n/** Iterates through all the existing points in given range */\nfunction iterate(range) {\n  var row, column;\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        row = range.start.row;\n        _a.label = 1;\n      case 1:\n        if (!(row <= range.end.row)) return [3 /*break*/, 6];\n        column = range.start.column;\n        _a.label = 2;\n      case 2:\n        if (!(column <= range.end.column)) return [3 /*break*/, 5];\n        return [4 /*yield*/, {\n          row: row,\n          column: column\n        }];\n      case 3:\n        _a.sent();\n        _a.label = 4;\n      case 4:\n        column++;\n        return [3 /*break*/, 2];\n      case 5:\n        row++;\n        return [3 /*break*/, 1];\n      case 6:\n        return [2 /*return*/];\n    }\n  });\n}\n/** Returns the size (rows x columns) of the given range */\nfunction size(range) {\n  var rows = range.end.row + 1 - range.start.row;\n  var columns = range.end.column + 1 - range.start.column;\n  return rows * columns;\n}\n/** Returns whether given point exists in given range */\nfunction has$3(range, point) {\n  return point.row >= range.start.row && point.column >= range.start.column && point.row <= range.end.row && point.column <= range.end.column;\n}\n/** Limits given masked range with given mask */\nfunction mask(masked, mask) {\n  return {\n    start: {\n      row: mask.start.row > masked.start.row ? mask.start.row : masked.start.row,\n      column: mask.start.column > masked.start.column ? mask.start.column : masked.start.column\n    },\n    end: {\n      row: mask.end.row < masked.end.row ? mask.end.row : masked.end.row,\n      column: mask.end.column < masked.end.column ? mask.end.column : masked.end.column\n    }\n  };\n}\nvar setData = createAction(\"SET_DATA\", function (data) {\n  return {\n    payload: {\n      data: data\n    }\n  };\n});\nvar select = createAction(\"SELECT\", function (point) {\n  return {\n    payload: {\n      point: point\n    }\n  };\n});\nvar activate = createAction(\"ACTIVATE\", function (point) {\n  return {\n    payload: {\n      point: point\n    }\n  };\n});\nvar setCellData = createAction(\"SET_CELL_DATA\", function (active, data, getBindingsForCell) {\n  return {\n    payload: {\n      active: active,\n      data: data,\n      getBindingsForCell: getBindingsForCell\n    }\n  };\n});\nvar setCellDimensions = createAction(\"SET_CELL_DIMENSIONS\", function (point, dimensions) {\n  return {\n    payload: {\n      point: point,\n      dimensions: dimensions\n    }\n  };\n});\nvar copy = createAction(\"COPY\");\nvar cut = createAction(\"CUT\");\nvar paste = createAction(\"PASTE\", function (data) {\n  return {\n    payload: {\n      data: data\n    }\n  };\n});\nvar edit$1 = createAction(\"EDIT\");\nvar view$1 = createAction(\"VIEW\");\nvar clear$1 = createAction(\"CLEAR\");\nvar blur$1 = createAction(\"BLUR\");\nvar keyPress = createAction(\"KEY_PRESS\", function (event) {\n  return {\n    payload: {\n      event: event\n    }\n  };\n});\nvar keyDown = createAction(\"KEY_DOWN\", function (event) {\n  return {\n    payload: {\n      event: event\n    }\n  };\n});\nvar dragStart = createAction(\"DRAG_START\");\nvar dragEnd = createAction(\"DRAG_END\");\nvar commit$1 = createAction(\"COMMIT\", function (changes) {\n  return {\n    payload: {\n      changes: changes\n    }\n  };\n});\n\n/** Sets the value for point in map */\nfunction set$1(point, value, map) {\n  var _a, _b;\n  return __assign(__assign({}, map), (_a = {}, _a[point.row] = __assign(__assign({}, map[point.row]), (_b = {}, _b[point.column] = value, _b)), _a));\n}\n/** Gets the value for point in map */\nfunction get$1(point, map) {\n  return map[point.row] && map[point.row][point.column];\n}\n/** Checks if map has point assigned to value */\nfunction has$2(point, map) {\n  return point.row in map && point.column in map[point.row];\n}\nvar EMPTY = {};\n/** Creates a new PointMap instance from an array-like or iterable object. */\nfunction from$1(pairs) {\n  return pairs.reduce(function (acc, _a) {\n    var _b = __read(_a, 2),\n      point = _b[0],\n      value = _b[1];\n    return set$1(point, value, acc);\n  }, EMPTY);\n}\n/** Creates a new PointMap instance from a Matrix. */\nfunction fromMatrix(matrix) {\n  return matrix.reduce(function (rowAcc, data, row) {\n    return data.reduce(function (colAcc, cell, column) {\n      return cell ? set$1({\n        row: row,\n        column: column\n      }, cell, colAcc) : colAcc;\n    }, rowAcc);\n  }, EMPTY);\n}\n/** Applies a function against an accumulator and each value and point in the map (from left to right) to reduce it to a single value */\nfunction reduce(func, map, initialValue) {\n  var acc = initialValue;\n  var _map_keys = Object.keys(map);\n  for (var i = 0; i < _map_keys.length; i++) {\n    var row = Number(_map_keys[i]);\n    var columns = map[row];\n    var _columns_keys = Object.keys(columns);\n    for (var j = 0; j < _columns_keys.length; j++) {\n      var column = Number(_columns_keys[j]);\n      var value = columns[column];\n      acc = func(acc, value, {\n        row: row,\n        column: column\n      });\n    }\n  }\n  return acc;\n}\n/** Creates a new map with the results of calling a provided function on every value in the calling map */\nfunction map$1(func, map) {\n  return reduce(function (acc, value, point) {\n    return set$1(point, func(value), acc);\n  }, map, from$1([]));\n}\n/** Creates a new map of all values predicate returns truthy for. The predicate is invoked with two arguments: (value, key) */\nfunction filter$1(predicate, map) {\n  return reduce(function (acc, value, point) {\n    if (predicate(value, point)) {\n      return set$1(point, value, acc);\n    }\n    return acc;\n  }, map, from$1([]));\n}\n/** Returns whether map has any points set to value */\nfunction isEmpty(map) {\n  return Object.keys(map).length === 0;\n}\n\n/**\r\n * Creates an empty matrix with given rows and columns\r\n * @param rows - integer, the amount of rows the matrix should have\r\n * @param columns - integer, the amount of columns the matrix should have\r\n * @returns an empty matrix with given rows and columns\r\n */\nfunction createEmpty(rows, columns) {\n  var matrix = Array(rows);\n  for (var i = 0; i < rows; i++) {\n    matrix[i] = Array(columns);\n  }\n  return matrix;\n}\n/** Gets the value at row and column of matrix. */\nfunction get(point, matrix) {\n  var columns = matrix[point.row];\n  if (columns === undefined) {\n    return undefined;\n  }\n  return columns[point.column];\n}\n/** Creates a slice of matrix from startPoint up to, but not including, endPoint. */\nfunction slice(startPoint, endPoint, matrix) {\n  var sliced = [];\n  var columns = endPoint.column - startPoint.column;\n  for (var row = startPoint.row; row <= endPoint.row; row++) {\n    var slicedRow = row - startPoint.row;\n    sliced[slicedRow] = sliced[slicedRow] || Array(columns);\n    for (var column = startPoint.column; column <= endPoint.column; column++) {\n      sliced[slicedRow][column - startPoint.column] = get({\n        row: row,\n        column: column\n      }, matrix);\n    }\n  }\n  return sliced;\n}\n/** Sets the value at row and column of matrix. If a row doesn't exist, it's created. */\nfunction set(point, value, matrix) {\n  var nextMatrix = __spreadArray([], __read(matrix));\n  // Synchronize first row length\n  var firstRow = matrix[0];\n  var nextFirstRow = firstRow ? __spreadArray([], __read(firstRow)) : [];\n  if (nextFirstRow.length - 1 < point.column) {\n    nextFirstRow[point.column] = undefined;\n    nextMatrix[0] = nextFirstRow;\n  }\n  var nextRow = matrix[point.row] ? __spreadArray([], __read(matrix[point.row])) : [];\n  nextRow[point.column] = value;\n  nextMatrix[point.row] = nextRow;\n  return nextMatrix;\n}\n/** Like Matrix.set() but mutates the matrix */\nfunction mutableSet(point, value, matrix) {\n  var firstRow = matrix[0];\n  if (!firstRow) {\n    firstRow = [];\n    matrix[0] = firstRow;\n  }\n  if (!(point.row in matrix)) {\n    matrix[point.row] = [];\n  }\n  // Synchronize first row length\n  if (!(point.column in firstRow)) {\n    firstRow[point.column] = undefined;\n  }\n  matrix[point.row][point.column] = value;\n}\n/** Removes the coordinate of matrix */\nfunction unset(point, matrix) {\n  if (!has$1(point, matrix)) {\n    return matrix;\n  }\n  var nextMatrix = __spreadArray([], __read(matrix));\n  var nextRow = __spreadArray([], __read(matrix[point.row]));\n  // Avoid deleting to preserve first row length\n  nextRow[point.column] = undefined;\n  nextMatrix[point.row] = nextRow;\n  return nextMatrix;\n}\n/** Creates an array of values by running each element in collection thru iteratee. */\nfunction map(func, matrix) {\n  var e_1, _a, e_2, _b;\n  var newMatrix = [];\n  try {\n    for (var _c = __values(matrix.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var _e = __read(_d.value, 2),\n        row = _e[0],\n        values = _e[1];\n      try {\n        for (var _f = (e_2 = void 0, __values(values.entries())), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var _h = __read(_g.value, 2),\n            column = _h[0],\n            value = _h[1];\n          var point = {\n            row: row,\n            column: column\n          };\n          mutableSet(point, func(value, point), newMatrix);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f[\"return\"])) _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c[\"return\"])) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return newMatrix;\n}\n/**\r\n * Converts all elements in row into a string separated by horizontalSeparator and each row string\r\n * to string separated by verticalSeparator\r\n */\nfunction join(matrix, horizontalSeparator, verticalSeparator) {\n  if (horizontalSeparator === void 0) {\n    horizontalSeparator = \"\\t\";\n  }\n  if (verticalSeparator === void 0) {\n    verticalSeparator = \"\\n\";\n  }\n  var joined = \"\";\n  var _a = getSize(matrix),\n    rows = _a.rows,\n    columns = _a.columns;\n  for (var row = 0; row < rows; row++) {\n    if (row) {\n      joined += verticalSeparator;\n    }\n    for (var column = 0; column < columns; column++) {\n      if (column) {\n        joined += horizontalSeparator;\n      }\n      if (matrix[row] && column in matrix[row]) {\n        joined += String(matrix[row][column]);\n      }\n    }\n  }\n  return joined;\n}\n/**\r\n * Parses a CSV separated by a horizontalSeparator and verticalSeparator into a\r\n * Matrix using a transform function\r\n */\nfunction split(csv, transform, horizontalSeparator, verticalSeparator) {\n  if (horizontalSeparator === void 0) {\n    horizontalSeparator = \"\\t\";\n  }\n  if (verticalSeparator === void 0) {\n    verticalSeparator = /\\r\\n|\\n|\\r/;\n  }\n  return csv.split(verticalSeparator).map(function (row) {\n    return row.split(horizontalSeparator).map(transform);\n  });\n}\n/** Returns whether the point exists in the matrix or not. */\nfunction has$1(point, matrix) {\n  var firstRow = matrix[0];\n  return firstRow &&\n  // validation\n  point.row >= 0 && point.column >= 0 && Number.isInteger(point.row) && Number.isInteger(point.column) &&\n  // first row length is in sync with other rows\n  point.column < firstRow.length && point.row < matrix.length;\n}\n/** Gets the size of matrix by returning its number of rows and columns */\nfunction getSize(matrix) {\n  var firstRow = matrix[0];\n  return {\n    columns: firstRow ? firstRow.length : 0,\n    rows: matrix.length\n  };\n}\n/**\r\n * Pads matrix with empty rows to match given total rows\r\n * @param matrix - matrix to pad\r\n * @param totalRows - number of rows the matrix should have\r\n * @returns the updated matrix\r\n */\nfunction padRows(matrix, totalRows) {\n  var _a = getSize(matrix),\n    rows = _a.rows,\n    columns = _a.columns;\n  if (rows >= totalRows) {\n    return matrix;\n  }\n  var missingRows = totalRows - rows;\n  var emptyRow = Array(columns).fill(undefined);\n  var emptyRows = Array(missingRows).fill(emptyRow);\n  return __spreadArray(__spreadArray([], __read(matrix), false), __read(emptyRows));\n}\n/**\r\n * Flattens a matrix values to an array\r\n * @param matrix - the matrix to flatten values from\r\n * @param transform - optional transform function to apply to each value in the\r\n * matrix\r\n * @returns an array of the values from matrix, transformed if a transform\r\n * function is passed\r\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction toArray(matrix, transform) {\n  var array = [];\n  for (var row = 0; row < matrix.length; row++) {\n    for (var column = 0; column < matrix[row].length; column++) {\n      var value = matrix[row][column];\n      array.push(transform ? transform(value, {\n        row: row,\n        column: column\n      }) : value);\n    }\n  }\n  return array;\n}\n/** Returns the maximum point in the matrix */\nfunction maxPoint(matrix) {\n  var size = getSize(matrix);\n  return {\n    row: size.rows - 1,\n    column: size.columns - 1\n  };\n}\n\n/** Return whether two given points are the equal */\nfunction isEqual(source, target) {\n  return source.column === target.column && source.row === target.row;\n}\n/** The origin point in matrices */\nvar ORIGIN = {\n  row: 0,\n  column: 0\n};\n\n/**\r\n * Immutable Set like interface of points\r\n */\n/** Returns a boolean asserting whether an point is present with the given value in the Set object or not */\nvar has = function (set, point) {\n  return has$2(point, set);\n};\n/** Creates a new set with all points that pass the test implemented by the provided function */\nfunction filter(func, set) {\n  return filter$1(function (_, point) {\n    return func(point);\n  }, set);\n}\nvar minKey = function (object) {\n  /* @ts-ignore*/\n  return Math.min.apply(Math, __spreadArray([], __read(Object.keys(object))));\n};\n/** Returns the point on the minimal row in the minimal column in the set */\nfunction min(set) {\n  var row = minKey(set);\n  return {\n    row: row,\n    column: minKey(set[row])\n  };\n}\nvar maxKey = function (object) {\n  // @ts-ignore\n  return Math.max.apply(Math, __spreadArray([], __read(Object.keys(object))));\n};\n/** Returns the point on the maximal row in the maximal column in the set */\nfunction max(set) {\n  var row = maxKey(set);\n  return {\n    row: row,\n    column: maxKey(set[row])\n  };\n}\n/** Creates a new PointSet instance from an array-like or iterable object */\nfunction from(points) {\n  return points.reduce(function (acc, point) {\n    return set$1(point, true, acc);\n  }, from$1([]));\n}\n/** Transform a point set to a range */\nfunction toRange(set) {\n  var start = min(set);\n  var end = max(set);\n  return create(start, end);\n}\nvar FORMULA_VALUE_PREFIX = \"=\";\nvar FORMULA_REFERENCES = /\\$?[A-Z]+\\$?[0-9]+/g;\n/** Returns whether given value is a formula */\nfunction isFormulaValue(value) {\n  return typeof value === \"string\" && value.startsWith(FORMULA_VALUE_PREFIX);\n}\n/** Extracts formula from value  */\nfunction extractFormula(value) {\n  return value.slice(1);\n}\n/**\r\n * For given formula returns the cell references\r\n * @param formula - formula to get references for\r\n */\nfunction getReferences(formula) {\n  var match = formula.match(FORMULA_REFERENCES);\n  return match ? match.map(function (substr) {\n    var _a = __read(extractLabel(substr), 2),\n      row = _a[0],\n      column = _a[1];\n    return {\n      row: row.index,\n      column: column.index\n    };\n  }) : [];\n}\nvar PLAIN_TEXT_MIME = \"text/plain\";\nvar FOCUS_WITHIN_SELECTOR = \":focus-within\";\n/** Move the cursor of given input element to the input's end */\nfunction moveCursorToEnd(el) {\n  el.selectionStart = el.selectionEnd = el.value.length;\n}\n/**\r\n * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end. A step of -1 is used if a negative start is specified without an end or step. If end is not specified, it's set to start with start then set to 0.\r\n * @param end - an integer number specifying at which position to stop (not included).\r\n * @param start - An integer number specifying at which position to start.\r\n * @param step - An integer number specifying the incrementation\r\n */\nfunction range(end, start, step) {\n  if (start === void 0) {\n    start = 0;\n  }\n  if (step === void 0) {\n    step = 1;\n  }\n  var array = [];\n  if (Math.sign(end - start) === -1) {\n    for (var element = start; element > end; element -= step) {\n      array.push(element);\n    }\n    return array;\n  }\n  for (var element = start; element < end; element += step) {\n    array.push(element);\n  }\n  return array;\n}\n/** Return whether given point is active */\nfunction isActive(active, point) {\n  return Boolean(active && isEqual(point, active));\n}\n/** Get the offset values of given element */\nfunction getOffsetRect(element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight,\n    left: element.offsetLeft,\n    top: element.offsetTop\n  };\n}\n/** Write given data to clipboard with given event */\nfunction writeTextToClipboard(event, data) {\n  var _a;\n  (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData(PLAIN_TEXT_MIME, data);\n}\n/** Read text from given clipboard event */\nfunction readTextFromClipboard(event) {\n  // @ts-ignore\n  if (window.clipboardData && window.clipboardData.getData) {\n    // @ts-ignore\n    return window.clipboardData.getData(\"Text\");\n  }\n  if (event.clipboardData && event.clipboardData.getData) {\n    return event.clipboardData.getData(PLAIN_TEXT_MIME);\n  }\n  return \"\";\n}\n/** Get the dimensions of cell at point from state */\nfunction getCellDimensions(point, rowDimensions, columnDimensions) {\n  var cellRowDimensions = rowDimensions && rowDimensions[point.row];\n  var cellColumnDimensions = columnDimensions && columnDimensions[point.column];\n  return cellRowDimensions && cellColumnDimensions && __assign(__assign({}, cellRowDimensions), cellColumnDimensions);\n}\n/** Get the dimensions of a range of cells */\nfunction getRangeDimensions(rowDimensions, columnDimensions, range) {\n  var startDimensions = getCellDimensions(range.start, rowDimensions, columnDimensions);\n  var endDimensions = getCellDimensions(range.end, rowDimensions, columnDimensions);\n  return startDimensions && endDimensions && {\n    width: endDimensions.left + endDimensions.width - startDimensions.left,\n    height: endDimensions.top + endDimensions.height - startDimensions.top,\n    top: startDimensions.top,\n    left: startDimensions.left\n  };\n}\n/** Get the computed value of a cell. */\nfunction getComputedValue(_a) {\n  var cell = _a.cell,\n    formulaParser = _a.formulaParser;\n  if (cell === undefined) {\n    return null;\n  }\n  if (isFormulaCell(cell)) {\n    return getFormulaComputedValue({\n      cell: cell,\n      formulaParser: formulaParser\n    });\n  }\n  return cell.value;\n}\n/** Get the computed value of a formula cell */\nfunction getFormulaComputedValue(_a) {\n  var cell = _a.cell,\n    formulaParser = _a.formulaParser;\n  var formula = extractFormula(cell.value);\n  var _b = formulaParser.parse(formula),\n    result = _b.result,\n    error = _b.error;\n  return error || result;\n}\n/** Returns whether given cell contains a formula value */\nfunction isFormulaCell(cell) {\n  return isFormulaValue(cell.value);\n}\n/** Normalize given selected range to given data matrix */\nfunction normalizeSelected(selected, data) {\n  var dataRange = getMatrixRange(data);\n  return selected && mask(selected, dataRange);\n}\n/** Get the point range of given matrix */\nfunction getMatrixRange(data) {\n  var maxPoint$1 = maxPoint(data);\n  return create(ORIGIN, maxPoint$1);\n}\n/** Get given selected range from given data as CSV */\nfunction getSelectedCSV(selected, data) {\n  if (!selected) {\n    return \"\";\n  }\n  var selectedData = getRangeFromMatrix(selected, data);\n  return getCSV(selectedData);\n}\n/** Get given data as CSV */\nfunction getCSV(data) {\n  var valueMatrix = map(function (cell) {\n    return (cell === null || cell === void 0 ? void 0 : cell.value) || \"\";\n  }, data);\n  return join(valueMatrix);\n}\nfunction getRangeFromMatrix(range, matrix) {\n  return slice(range.start, range.end, matrix);\n}\n/**\r\n * Calculate the rows and columns counts of a spreadsheet\r\n * @param data - the spreadsheet's data\r\n * @param rowLabels - the spreadsheet's row labels (if defined)\r\n * @param columnLabels - the spreadsheet's column labels (if defined)\r\n * @returns the rows and columns counts of a spreadsheet\r\n */\nfunction calculateSpreadsheetSize(data, rowLabels, columnLabels) {\n  var _a = getSize(data),\n    columns = _a.columns,\n    rows = _a.rows;\n  return {\n    rows: rowLabels ? Math.max(rows, rowLabels.length) : rows,\n    columns: columnLabels ? Math.max(columns, columnLabels.length) : columns\n  };\n}\n/** Transform given point map to a point set */\nfunction convertPointMapToPointSet(map) {\n  return map$1(function () {\n    return true;\n  }, map);\n}\n/** Get the range of copied cells. If none are copied return null */\nfunction getCopiedRange(copied, hasPasted) {\n  if (hasPasted || isEmpty(copied)) {\n    return null;\n  }\n  var set = convertPointMapToPointSet(copied);\n  return toRange(set);\n}\n/** Tranform given hot-formula-parser coord to Point.Point */\nfunction transformCoordToPoint(coord) {\n  return {\n    row: coord.row.index,\n    column: coord.column.index\n  };\n}\n/**\r\n * Get cell value for given point from given spreadsheet data with evaluated\r\n * cells using given formulaParser\r\n */\nfunction getCellValue(formulaParser, data, point) {\n  return getComputedValue({\n    cell: get(point, data),\n    formulaParser: formulaParser\n  });\n}\n/**\r\n * Get cell range value for given start and end points from given spreadsheet\r\n * data with evaluated cells using given formulaParser\r\n */\nfunction getCellRangeValue(formulaParser, data, start, end) {\n  return toArray(slice(start, end, data), function (cell) {\n    return getComputedValue({\n      cell: cell,\n      formulaParser: formulaParser\n    });\n  });\n}\n/** Should spreadsheet handle clipboard event */\nfunction shouldHandleClipboardEvent(root, mode) {\n  return root !== null && mode === \"view\" && isFocusedWithin(root);\n}\nfunction isFocusedWithin(element) {\n  return element.matches(FOCUS_WITHIN_SELECTOR);\n}\nvar Table = function (_a) {\n  var children = _a.children,\n    columns = _a.columns,\n    hideColumnIndicators = _a.hideColumnIndicators;\n  var columnCount = columns + (hideColumnIndicators ? 0 : 1);\n  var columnNodes = range(columnCount).map(function (i) {\n    return React.createElement(\"col\", {\n      key: i\n    });\n  });\n  return React.createElement(\"table\", {\n    className: \"Spreadsheet__table\"\n  }, React.createElement(\"colgroup\", null, columnNodes), React.createElement(\"tbody\", null, children));\n};\nvar Row = function (props) {\n  return React.createElement(\"tr\", __assign({}, props));\n};\nvar HeaderRow = function (props) {\n  return React.createElement(\"tr\", __assign({}, props));\n};\nvar CornerIndicator = function () {\n  return React.createElement(\"th\", {\n    className: \"Spreadsheet__header\"\n  });\n};\nvar ColumnIndicator = function (_a) {\n  var column = _a.column,\n    label = _a.label;\n  return React.createElement(\"th\", {\n    className: \"Spreadsheet__header\"\n  }, label !== undefined ? label : columnIndexToLabel(String(column)));\n};\nvar RowIndicator = function (_a) {\n  var row = _a.row,\n    label = _a.label;\n  return React.createElement(\"th\", {\n    className: \"Spreadsheet__header\"\n  }, label !== undefined ? label : row + 1);\n};\nvar Direction;\n(function (Direction) {\n  Direction[\"Left\"] = \"Left\";\n  Direction[\"Right\"] = \"Right\";\n  Direction[\"Top\"] = \"Top\";\n  Direction[\"Down\"] = \"Down\";\n})(Direction || (Direction = {}));\nvar INITIAL_STATE = {\n  active: null,\n  mode: \"view\",\n  rowDimensions: {},\n  columnDimensions: {},\n  lastChanged: null,\n  hasPasted: false,\n  cut: false,\n  dragging: false,\n  data: [],\n  selected: null,\n  copied: from$1([]),\n  bindings: from$1([]),\n  lastCommit: null\n};\nvar reducer = createReducer(INITIAL_STATE, function (builder) {\n  builder.addCase(setData, function (state, action) {\n    var data = action.payload.data;\n    var nextActive = state.active && has$1(state.active, data) ? state.active : null;\n    var nextSelected = normalizeSelected(state.selected, data);\n    var nextBindings = map$1(function (bindings) {\n      return filter(function (point) {\n        return has$1(point, data);\n      }, bindings);\n    }, filter$1(function (_, point) {\n      return has$1(point, data);\n    }, state.bindings));\n    return __assign(__assign({}, state), {\n      data: data,\n      active: nextActive,\n      selected: nextSelected,\n      bindings: nextBindings\n    });\n  });\n  builder.addCase(select, function (state, action) {\n    var point = action.payload.point;\n    if (state.active && !isActive(state.active, point)) {\n      return __assign(__assign({}, state), {\n        selected: create(point, state.active),\n        mode: \"view\"\n      });\n    }\n  });\n  builder.addCase(activate, function (state, action) {\n    var point = action.payload.point;\n    return __assign(__assign({}, state), {\n      selected: create(point, point),\n      active: point,\n      mode: isActive(state.active, point) ? \"edit\" : \"view\"\n    });\n  });\n  builder.addCase(setCellData, function (state, action) {\n    var _a = action.payload,\n      active = _a.active,\n      cellData = _a.data,\n      getBindingsForCell = _a.getBindingsForCell;\n    var bindings = getBindingsForCell(cellData, state.data);\n    if (isActiveReadOnly(state)) {\n      return;\n    }\n    return __assign(__assign({}, state), {\n      mode: \"edit\",\n      data: set(active, cellData, state.data),\n      lastChanged: active,\n      bindings: set$1(active, from(bindings), state.bindings)\n    });\n  });\n  builder.addCase(setCellDimensions, function (state, action) {\n    var _a, _b;\n    var _c = action.payload,\n      point = _c.point,\n      dimensions = _c.dimensions;\n    var prevRowDimensions = state.rowDimensions[point.row];\n    var prevColumnDimensions = state.columnDimensions[point.column];\n    if (prevRowDimensions && prevColumnDimensions && prevRowDimensions.top === dimensions.top && prevRowDimensions.height === dimensions.height && prevColumnDimensions.left === dimensions.left && prevColumnDimensions.width === dimensions.width) {\n      return;\n    }\n    return __assign(__assign({}, state), {\n      rowDimensions: __assign(__assign({}, state.rowDimensions), (_a = {}, _a[point.row] = {\n        top: dimensions.top,\n        height: dimensions.height\n      }, _a)),\n      columnDimensions: __assign(__assign({}, state.columnDimensions), (_b = {}, _b[point.column] = {\n        left: dimensions.left,\n        width: dimensions.width\n      }, _b))\n    });\n  });\n  builder.addCase(paste, function (state, action) {\n    var text = action.payload.data;\n    var active = state.active;\n    if (!active) {\n      return;\n    }\n    var copiedMatrix = split(text, function (value) {\n      return {\n        value: value\n      };\n    });\n    var copied = fromMatrix(copiedMatrix);\n    var minPoint = min(copied);\n    var copiedSize = getSize(copiedMatrix);\n    var requiredRows = active.row + copiedSize.rows;\n    var paddedData = padRows(state.data, requiredRows);\n    var _a = reduce(function (acc, value, point) {\n        var commit = acc.commit || [];\n        var nextPoint = {\n          row: point.row - minPoint.row + active.row,\n          column: point.column - minPoint.column + active.column\n        };\n        var nextData = state.cut ? unset(point, acc.data) : acc.data;\n        if (state.cut) {\n          commit = __spreadArray(__spreadArray([], __read(commit), false), [{\n            prevCell: value,\n            nextCell: null\n          }]);\n        }\n        if (!has$1(nextPoint, paddedData)) {\n          return {\n            data: nextData,\n            commit: commit\n          };\n        }\n        var currentValue = get(nextPoint, nextData) || null;\n        commit = __spreadArray(__spreadArray([], __read(commit), false), [{\n          prevCell: currentValue,\n          nextCell: value\n        }]);\n        return {\n          data: set(nextPoint, __assign(__assign({}, currentValue), value), nextData),\n          commit: commit\n        };\n      }, copied, {\n        data: paddedData,\n        commit: []\n      }),\n      data = _a.data,\n      commit = _a.commit;\n    return __assign(__assign({}, state), {\n      data: data,\n      selected: create(active, {\n        row: active.row + copiedSize.rows - 1,\n        column: active.column + copiedSize.columns - 1\n      }),\n      cut: false,\n      hasPasted: true,\n      mode: \"view\",\n      lastCommit: commit\n    });\n  });\n  builder.addCase(edit$1, edit);\n  builder.addCase(view$1, view);\n  builder.addCase(clear$1, clear);\n  builder.addCase(blur$1, blur);\n  builder.addCase(keyPress, function (state, action) {\n    var event = action.payload.event;\n    if (isActiveReadOnly(state) || event.metaKey) {\n      return;\n    }\n    if (state.mode === \"view\" && state.active) {\n      return edit(state);\n    }\n    return;\n  });\n  builder.addCase(keyDown, function (state, action) {\n    var event = action.payload.event;\n    var handler = getKeyDownHandler(state, event);\n    if (handler) {\n      return __assign(__assign({}, state), handler(state, event));\n    }\n    return;\n  });\n  builder.addCase(dragStart, function (state, action) {\n    return __assign(__assign({}, state), {\n      dragging: true\n    });\n  });\n  builder.addCase(dragEnd, function (state, action) {\n    return __assign(__assign({}, state), {\n      dragging: false\n    });\n  });\n  builder.addCase(commit$1, function (state, action) {\n    var changes = action.payload.changes;\n    return __assign(__assign({}, state), commit(changes));\n  });\n  builder.addMatcher(function (action) {\n    return action.type === copy.type || action.type === cut.type;\n  }, function (state, action) {\n    var selectedPoints = state.selected ? Array.from(iterate(state.selected)) : [];\n    return __assign(__assign({}, state), {\n      copied: selectedPoints.reduce(function (acc, point) {\n        var cell = get(point, state.data);\n        return cell === undefined ? acc : set$1(point, cell, acc);\n      }, from$1([])),\n      cut: action.type === cut.type,\n      hasPasted: false\n    });\n  });\n});\n// Shared reducers\nfunction edit(state) {\n  if (isActiveReadOnly(state)) {\n    return;\n  }\n  return __assign(__assign({}, state), {\n    mode: \"edit\"\n  });\n}\nfunction clear(state) {\n  if (!state.active) {\n    return;\n  }\n  var selectedPoints = state.selected ? Array.from(iterate(state.selected)) : [];\n  var changes = selectedPoints.map(function (point) {\n    var cell = get(point, state.data);\n    return __assign(__assign({}, state), {\n      prevCell: cell || null,\n      nextCell: null\n    });\n  });\n  return __assign(__assign(__assign({}, state), {\n    data: selectedPoints.reduce(function (acc, point) {\n      return set(point, undefined, acc);\n    }, state.data)\n  }), commit(changes));\n}\nfunction blur(state) {\n  return __assign(__assign({}, state), {\n    active: null,\n    selected: null\n  });\n}\nfunction view(state) {\n  return __assign(__assign({}, state), {\n    mode: \"view\"\n  });\n}\nfunction commit(changes) {\n  return {\n    lastCommit: changes\n  };\n}\n// Utility\nvar go = function (rowDelta, columnDelta) {\n  return function (state) {\n    if (!state.active) {\n      return;\n    }\n    var nextActive = {\n      row: state.active.row + rowDelta,\n      column: state.active.column + columnDelta\n    };\n    if (!has$1(nextActive, state.data)) {\n      return __assign(__assign({}, state), {\n        mode: \"view\"\n      });\n    }\n    return __assign(__assign({}, state), {\n      active: nextActive,\n      selected: create(nextActive, nextActive),\n      mode: \"view\"\n    });\n  };\n};\nvar keyDownHandlers = {\n  ArrowUp: go(-1, 0),\n  ArrowDown: go(+1, 0),\n  ArrowLeft: go(0, -1),\n  ArrowRight: go(0, +1),\n  Tab: go(0, +1),\n  Enter: edit,\n  Backspace: clear,\n  Escape: blur\n};\nvar editKeyDownHandlers = {\n  Escape: view,\n  Tab: keyDownHandlers.Tab,\n  Enter: keyDownHandlers.ArrowDown\n};\nvar editShiftKeyDownHandlers = {\n  Tab: go(0, -1)\n};\nvar modifyEdge = function (edge) {\n  return function (state) {\n    var _a, _b, _c;\n    var active = state.active,\n      selected = state.selected;\n    if (!active || !selected) {\n      return;\n    }\n    var field = edge === Direction.Left || edge === Direction.Right ? \"column\" : \"row\";\n    var key = edge === Direction.Left || edge === Direction.Top ? \"start\" : \"end\";\n    var delta = key === \"start\" ? -1 : 1;\n    var edgeOffsets = has$3(selected, __assign(__assign({}, active), (_a = {}, _a[field] = active[field] + delta * -1, _a)));\n    var keyToModify = edgeOffsets ? key === \"start\" ? \"end\" : \"start\" : key;\n    var nextSelected = __assign(__assign({}, selected), (_b = {}, _b[keyToModify] = __assign(__assign({}, selected[keyToModify]), (_c = {}, _c[field] = selected[keyToModify][field] + delta, _c)), _b));\n    return __assign(__assign({}, state), {\n      selected: normalizeSelected(nextSelected, state.data)\n    });\n  };\n};\nvar shiftKeyDownHandlers = {\n  ArrowUp: modifyEdge(Direction.Top),\n  ArrowDown: modifyEdge(Direction.Down),\n  ArrowLeft: modifyEdge(Direction.Left),\n  ArrowRight: modifyEdge(Direction.Right),\n  Tab: go(0, -1)\n};\nvar shiftMetaKeyDownHandlers = {};\nvar metaKeyDownHandlers = {};\nfunction getKeyDownHandler(state, event) {\n  var key = event.key;\n  var handlers;\n  // Order matters\n  if (state.mode === \"edit\") {\n    if (event.shiftKey) {\n      handlers = editShiftKeyDownHandlers;\n    } else {\n      handlers = editKeyDownHandlers;\n    }\n  } else if (event.shiftKey && event.metaKey) {\n    handlers = shiftMetaKeyDownHandlers;\n  } else if (event.shiftKey) {\n    handlers = shiftKeyDownHandlers;\n  } else if (event.metaKey) {\n    handlers = metaKeyDownHandlers;\n  } else {\n    handlers = keyDownHandlers;\n  }\n  return handlers[key];\n}\n/** Returns whether the reducer has a handler for the given keydown event */\nfunction hasKeyDownHandler(state, event) {\n  return getKeyDownHandler(state, event) !== undefined;\n}\n/** Returns whether the active cell is read only */\nfunction isActiveReadOnly(state) {\n  var activeCell = getActive(state);\n  return Boolean(activeCell === null || activeCell === void 0 ? void 0 : activeCell.readOnly);\n}\n/** Gets active cell from given state */\nfunction getActive(state) {\n  var activeCell = state.active && get(state.active, state.data);\n  return activeCell || null;\n}\nvar context = createContext([INITIAL_STATE, function () {}]);\nfunction useDispatch() {\n  return useContextSelector(context, function (_a) {\n    var _b = __read(_a, 2);\n    _b[0];\n    var dispatch = _b[1];\n    return dispatch;\n  });\n}\nfunction useSelector(selector) {\n  return useContextSelector(context, function (_a) {\n    var _b = __read(_a, 1),\n      state = _b[0];\n    return selector(state);\n  });\n}\nvar Cell = function (_a) {\n  var row = _a.row,\n    column = _a.column,\n    DataViewer = _a.DataViewer,\n    formulaParser = _a.formulaParser,\n    selected = _a.selected,\n    active = _a.active,\n    dragging = _a.dragging,\n    mode = _a.mode,\n    data = _a.data,\n    select = _a.select,\n    activate = _a.activate,\n    setCellDimensions = _a.setCellDimensions;\n  var rootRef = React.useRef(null);\n  var point = React.useMemo(function () {\n    return {\n      row: row,\n      column: column\n    };\n  }, [row, column]);\n  var handleMouseDown = React.useCallback(function (event) {\n    if (mode === \"view\") {\n      setCellDimensions(point, getOffsetRect(event.currentTarget));\n      if (event.shiftKey) {\n        select(point);\n      } else {\n        activate(point);\n      }\n    }\n  }, [mode, setCellDimensions, point, select, activate]);\n  var handleMouseOver = React.useCallback(function (event) {\n    if (dragging) {\n      setCellDimensions(point, getOffsetRect(event.currentTarget));\n      select(point);\n    }\n  }, [setCellDimensions, select, dragging, point]);\n  React.useEffect(function () {\n    var root = rootRef.current;\n    if (selected && root) {\n      setCellDimensions(point, getOffsetRect(root));\n    }\n    if (root && active && mode === \"view\") {\n      root.focus();\n    }\n  }, [setCellDimensions, selected, active, mode, point]);\n  if (data && data.DataViewer) {\n    // @ts-ignore\n    DataViewer = data.DataViewer;\n  }\n  return React.createElement(\"td\", {\n    ref: rootRef,\n    className: classnames(\"Spreadsheet__cell\", data === null || data === void 0 ? void 0 : data.className, {\n      \"Spreadsheet__cell--readonly\": data === null || data === void 0 ? void 0 : data.readOnly\n    }),\n    onMouseOver: handleMouseOver,\n    onMouseDown: handleMouseDown,\n    tabIndex: 0\n  }, React.createElement(DataViewer, {\n    row: row,\n    column: column,\n    cell: data,\n    formulaParser: formulaParser\n  }));\n};\nvar enhance = function (CellComponent) {\n  return function CellWrapper(props) {\n    var row = props.row,\n      column = props.column;\n    var dispatch = useDispatch();\n    var select$1 = React.useCallback(function (point) {\n      return dispatch(select(point));\n    }, [dispatch]);\n    var activate$1 = React.useCallback(function (point) {\n      return dispatch(activate(point));\n    }, [dispatch]);\n    var setCellDimensions$1 = React.useCallback(function (point, dimensions) {\n      return dispatch(setCellDimensions(point, dimensions));\n    }, [dispatch]);\n    var active = useSelector(function (state) {\n      return isActive(state.active, {\n        row: row,\n        column: column\n      });\n    });\n    var mode = useSelector(function (state) {\n      return active ? state.mode : \"view\";\n    });\n    var data = useSelector(function (state) {\n      return get({\n        row: row,\n        column: column\n      }, state.data);\n    });\n    var selected = useSelector(function (state) {\n      return state.selected ? has$3(state.selected, {\n        row: row,\n        column: column\n      }) : false;\n    });\n    var dragging = useSelector(function (state) {\n      return state.dragging;\n    });\n    var copied = useSelector(function (state) {\n      return has$2({\n        row: row,\n        column: column\n      }, state.copied);\n    });\n    // Use only to trigger re-render when cell bindings change\n    useSelector(function (state) {\n      var point = {\n        row: row,\n        column: column\n      };\n      var cellBindings = get$1(point, state.bindings);\n      return cellBindings && state.lastChanged && has(cellBindings, state.lastChanged) ? {} : null;\n    });\n    return React.createElement(CellComponent, __assign({}, props, {\n      selected: selected,\n      active: active,\n      copied: copied,\n      dragging: dragging,\n      mode: mode,\n      data: data,\n      select: select$1,\n      activate: activate$1,\n      setCellDimensions: setCellDimensions$1\n    }));\n  };\n};\nvar TRUE_TEXT = \"TRUE\";\nvar FALSE_TEXT = \"FALSE\";\n/** The default Spreadsheet DataViewer component */\nvar DataViewer = function (_a) {\n  var cell = _a.cell,\n    formulaParser = _a.formulaParser;\n  var value = getComputedValue({\n    cell: cell,\n    formulaParser: formulaParser\n  });\n  return typeof value === \"boolean\" ? React.createElement(\"span\", {\n    className: \"Spreadsheet__data-viewer Spreadsheet__data-viewer--boolean\"\n  }, convertBooleanToText(value)) : React.createElement(\"span\", {\n    className: \"Spreadsheet__data-viewer\"\n  }, value);\n};\nfunction convertBooleanToText(value) {\n  return value ? TRUE_TEXT : FALSE_TEXT;\n}\n\n/** The default Spreadsheet DataEditor component */\nvar DataEditor = function (_a) {\n  var _b;\n  var onChange = _a.onChange,\n    cell = _a.cell;\n  var inputRef = React.useRef(null);\n  var handleChange = React.useCallback(function (event) {\n    onChange(__assign(__assign({}, cell), {\n      value: event.target.value\n    }));\n  }, [onChange, cell]);\n  React.useEffect(function () {\n    if (inputRef.current) {\n      moveCursorToEnd(inputRef.current);\n    }\n  }, [inputRef]);\n  var value = (_b = cell === null || cell === void 0 ? void 0 : cell.value) !== null && _b !== void 0 ? _b : \"\";\n  return React.createElement(\"div\", {\n    className: \"Spreadsheet__data-editor\"\n  }, React.createElement(\"input\", {\n    ref: inputRef,\n    type: \"text\",\n    onChange: handleChange,\n    value: value,\n    autoFocus: true\n  }));\n};\nvar ActiveCell = function (props) {\n  var rootRef = React.useRef(null);\n  var getBindingsForCell = props.getBindingsForCell;\n  var dispatch = useDispatch();\n  var setCellData$1 = React.useCallback(function (active, data) {\n    return dispatch(setCellData(active, data, getBindingsForCell));\n  }, [dispatch, getBindingsForCell]);\n  var edit = React.useCallback(function () {\n    return dispatch(edit$1());\n  }, [dispatch]);\n  var commit = React.useCallback(function (changes) {\n    return dispatch(commit$1(changes));\n  }, [dispatch]);\n  var view = React.useCallback(function () {\n    dispatch(view$1());\n  }, [dispatch]);\n  var active = useSelector(function (state) {\n    return state.active;\n  });\n  var mode = useSelector(function (state) {\n    return state.mode;\n  });\n  var cell = useSelector(function (state) {\n    return state.active ? get(state.active, state.data) : undefined;\n  });\n  var dimensions = useSelector(function (state) {\n    return active ? getCellDimensions(active, state.rowDimensions, state.columnDimensions) : undefined;\n  });\n  var hidden = React.useMemo(function () {\n    return !active || !dimensions;\n  }, [active, dimensions]);\n  var initialCellRef = React.useRef(undefined);\n  var prevActiveRef = React.useRef(null);\n  var prevCellRef = React.useRef(undefined);\n  var handleChange = React.useCallback(function (cell) {\n    if (!active) {\n      return;\n    }\n    setCellData$1(active, cell);\n  }, [setCellData$1, active]);\n  React.useEffect(function () {\n    var root = rootRef.current;\n    if (!hidden && root) {\n      root.focus();\n    }\n  }, [rootRef, hidden]);\n  React.useEffect(function () {\n    var prevActive = prevActiveRef.current;\n    var prevCell = prevCellRef.current;\n    prevActiveRef.current = active;\n    prevCellRef.current = cell;\n    if (!prevActive || !prevCell) {\n      return;\n    }\n    // Commit\n    var coordsChanged = (active === null || active === void 0 ? void 0 : active.row) !== prevActive.row || (active === null || active === void 0 ? void 0 : active.column) !== prevActive.column;\n    var exitedEditMode = mode !== \"edit\";\n    if (coordsChanged || exitedEditMode) {\n      var initialCell = initialCellRef.current;\n      if (prevCell !== initialCell) {\n        commit([{\n          prevCell: initialCell || null,\n          nextCell: prevCell\n        }]);\n      } else if (!coordsChanged && cell !== prevCell) {\n        commit([{\n          prevCell: prevCell,\n          nextCell: cell || null\n        }]);\n      }\n      initialCellRef.current = cell;\n    }\n  });\n  var DataEditor = cell && cell.DataEditor || props.DataEditor;\n  var readOnly = cell && cell.readOnly;\n  return hidden ? null : React.createElement(\"div\", {\n    ref: rootRef,\n    className: classnames(\"Spreadsheet__active-cell\", \"Spreadsheet__active-cell--\" + mode),\n    style: dimensions,\n    onClick: mode === \"view\" && !readOnly ? edit : undefined,\n    tabIndex: 0\n  }, mode === \"edit\" && active && React.createElement(DataEditor, {\n    row: active.row,\n    column: active.column,\n    cell: cell,\n    // @ts-ignore\n    onChange: handleChange,\n    exitEditMode: view\n  }));\n};\nvar FloatingRect = function (_a) {\n  var _b;\n  var dimensions = _a.dimensions,\n    dragging = _a.dragging,\n    hidden = _a.hidden,\n    variant = _a.variant;\n  var _c = dimensions || {},\n    width = _c.width,\n    height = _c.height,\n    top = _c.top,\n    left = _c.left;\n  return React.createElement(\"div\", {\n    className: classnames(\"Spreadsheet__floating-rect\", (_b = {}, _b[\"Spreadsheet__floating-rect--\" + variant] = variant, _b[\"Spreadsheet__floating-rect--dragging\"] = dragging, _b[\"Spreadsheet__floating-rect--hidden\"] = hidden, _b)),\n    style: {\n      width: width,\n      height: height,\n      top: top,\n      left: left\n    }\n  });\n};\nvar Selected = function () {\n  var selected = useSelector(function (state) {\n    return state.selected;\n  });\n  var dimensions = useSelector(function (state) {\n    return selected && getRangeDimensions(state.rowDimensions, state.columnDimensions, selected);\n  });\n  var dragging = useSelector(function (state) {\n    return state.dragging;\n  });\n  var hidden = React.useMemo(function () {\n    return isHidden(selected);\n  }, [selected]);\n  return React.createElement(FloatingRect, {\n    variant: \"selected\",\n    dimensions: dimensions,\n    dragging: dragging,\n    hidden: hidden\n  });\n};\nfunction isHidden(selected) {\n  return !selected || Boolean(selected && size(selected) === 1);\n}\nvar Copied = function () {\n  var range = useSelector(function (state) {\n    return getCopiedRange(state.copied, state.hasPasted);\n  });\n  var dimensions = useSelector(function (state) {\n    return range && getRangeDimensions(state.rowDimensions, state.columnDimensions, range);\n  });\n  var hidden = range === null;\n  return React.createElement(FloatingRect, {\n    variant: \"copied\",\n    dimensions: dimensions,\n    hidden: hidden,\n    dragging: false\n  });\n};\n\n/**\r\n * For given cell and spreadsheet data returns the cells affecting the cell value\r\n * @param cell - cell to get bindings for\r\n * @param data - spreadsheet data the cell relates to\r\n * @returns an array of coordinates in the given spreadsheet data of the cells that affect the given cell\r\n */\nvar getBindingsForCell = function (cell, data) {\n  if (!isFormulaValue(cell.value)) {\n    return [];\n  }\n  var formula = cell.value;\n  var references = getReferences(formula);\n  // Recursively get references to dependencies\n  return flatMap(references, function (coords) {\n    var dependency = get(coords, data);\n    var dependencyBindings = dependency ? getBindingsForCell(dependency, data) : [];\n    return __spreadArray([coords], __read(dependencyBindings));\n  });\n};\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\nvar css_248z = \".Spreadsheet {\\n  --background-color: white;\\n  --text-color: black;\\n  --readonly-text-color: rgba(0, 0, 0, 0.4);\\n  --outline-color: #4285f4;\\n  --outline-background-color: rgba(160, 195, 255, 0.2);\\n  --border-color: hsl(2deg, 0%, 91%);\\n  --header-background-color: rgba(0, 0, 0, 0.04);\\n  --elevation: 0 2px 5px rgba(0, 0, 0, 0.4);\\n\\n  position: relative;\\n  overflow: visible;\\n  background: var(--background-color);\\n  color: var(--text-color);\\n  display: inline-block;\\n}\\n\\n.Spreadsheet--dark-mode {\\n  --background-color: black;\\n  --text-color: white;\\n  --readonly-text-color: rgba(255, 255, 255, 0.4);\\n  --header-background-color: rgba(255, 255, 255, 0.04);\\n  --border-color: hsl(2deg, 0%, 19%);\\n}\\n\\n.Spreadsheet__active-cell {\\n  position: absolute;\\n  border: 2px solid var(--outline-color);\\n  box-sizing: border-box;\\n}\\n\\n.Spreadsheet__active-cell--edit {\\n  background: var(--background-color);\\n  box-shadow: var(--elevation);\\n}\\n\\n.Spreadsheet__table {\\n  border-collapse: collapse;\\n  table-layout: fixed;\\n}\\n\\n.Spreadsheet__cell,\\n.Spreadsheet__active-cell {\\n  cursor: cell;\\n}\\n\\n.Spreadsheet__cell {\\n  outline: none;\\n}\\n\\n.Spreadsheet__cell--readonly {\\n  color: var(--readonly-text-color);\\n}\\n\\n.Spreadsheet__cell,\\n.Spreadsheet__header {\\n  min-width: 6em;\\n  min-height: 1.9em;\\n  height: 1.9em;\\n  max-height: 1.9em;\\n  border: 1px solid var(--border-color);\\n  overflow: hidden;\\n  word-break: keep-all;\\n  white-space: nowrap;\\n  text-align: left;\\n  box-sizing: border-box;\\n  user-select: none;\\n}\\n\\n.Spreadsheet__header {\\n  background: var(--header-background-color);\\n  color: var(--readonly-text-color);\\n  text-align: center;\\n  font: inherit;\\n}\\n\\n.Spreadsheet__header,\\n.Spreadsheet__data-viewer,\\n.Spreadsheet__data-editor input {\\n  padding: 4px;\\n  box-sizing: border-box;\\n}\\n\\n.Spreadsheet__data-editor,\\n.Spreadsheet__data-editor input {\\n  width: 98%;\\n  height: 98%;\\n}\\n\\n.Spreadsheet__data-editor input {\\n  font: inherit;\\n  color: inherit;\\n  background: none;\\n  border: none;\\n  outline: none;\\n  margin: 0;\\n}\\n\\n.Spreadsheet__data-viewer--boolean {\\n  text-align: center;\\n}\\n\\n.Spreadsheet__floating-rect {\\n  position: absolute;\\n  pointer-events: none;\\n  box-sizing: border-box;\\n}\\n\\n.Spreadsheet__floating-rect--hidden {\\n  display: none;\\n}\\n\\n.Spreadsheet__floating-rect--selected {\\n  background: var(--outline-background-color);\\n  border: 2px var(--outline-color) solid;\\n}\\n\\n.Spreadsheet__floating-rect--dragging {\\n  border: none;\\n}\\n\\n.Spreadsheet__floating-rect--copied {\\n  border: 2px var(--outline-color) dashed;\\n}\\n\";\nstyleInject(css_248z);\n\n/**\r\n * The Spreadsheet component\r\n */\nvar Spreadsheet = function (props) {\n  var className = props.className,\n    darkMode = props.darkMode,\n    columnLabels = props.columnLabels,\n    rowLabels = props.rowLabels,\n    hideColumnIndicators = props.hideColumnIndicators,\n    hideRowIndicators = props.hideRowIndicators,\n    onKeyDown = props.onKeyDown,\n    _a = props.Table,\n    Table$1 = _a === void 0 ? Table : _a,\n    _b = props.Row,\n    Row$1 = _b === void 0 ? Row : _b,\n    _c = props.HeaderRow,\n    HeaderRow$1 = _c === void 0 ? HeaderRow : _c,\n    _d = props.CornerIndicator,\n    CornerIndicator$1 = _d === void 0 ? CornerIndicator : _d,\n    _e = props.DataEditor,\n    DataEditor$1 = _e === void 0 ? DataEditor : _e,\n    _f = props.DataViewer,\n    DataViewer$1 = _f === void 0 ? DataViewer : _f,\n    _g = props.getBindingsForCell,\n    getBindingsForCell$1 = _g === void 0 ? getBindingsForCell : _g,\n    _h = props.RowIndicator,\n    RowIndicator$1 = _h === void 0 ? RowIndicator : _h,\n    _j = props.ColumnIndicator,\n    ColumnIndicator$1 = _j === void 0 ? ColumnIndicator : _j,\n    _k = props.onChange,\n    onChange = _k === void 0 ? function () {} : _k,\n    _l = props.onModeChange,\n    onModeChange = _l === void 0 ? function () {} : _l,\n    _m = props.onSelect,\n    onSelect = _m === void 0 ? function () {} : _m,\n    _o = props.onActivate,\n    onActivate = _o === void 0 ? function () {} : _o,\n    _p = props.onBlur,\n    onBlur = _p === void 0 ? function () {} : _p,\n    _q = props.onCellCommit,\n    onCellCommit = _q === void 0 ? function () {} : _q;\n  var initialState = React.useMemo(function () {\n    return __assign(__assign({}, INITIAL_STATE), {\n      data: props.data\n    });\n  }, [props.data]);\n  var reducerElements = React.useReducer(reducer, initialState);\n  var _r = __read(reducerElements, 2),\n    state = _r[0],\n    dispatch = _r[1];\n  var size = React.useMemo(function () {\n    return calculateSpreadsheetSize(state.data, rowLabels, columnLabels);\n  }, [state.data, rowLabels, columnLabels]);\n  var mode = state.mode;\n  var rootRef = React.useRef(null);\n  var prevStateRef = React.useRef(__assign(__assign({}, INITIAL_STATE), {\n    data: props.data,\n    selected: null,\n    copied: from$1([]),\n    bindings: from$1([]),\n    lastCommit: null\n  }));\n  var copy$1 = React.useCallback(function () {\n    return dispatch(copy());\n  }, [dispatch]);\n  var cut$1 = React.useCallback(function () {\n    return dispatch(cut());\n  }, [dispatch]);\n  var paste$1 = React.useCallback(function (data) {\n    return dispatch(paste(data));\n  }, [dispatch]);\n  var onKeyDownAction = React.useCallback(function (event) {\n    return dispatch(keyDown(event));\n  }, [dispatch]);\n  var onKeyPress = React.useCallback(function (event) {\n    return dispatch(keyPress(event));\n  }, [dispatch]);\n  var onDragStart = React.useCallback(function () {\n    return dispatch(dragStart());\n  }, [dispatch]);\n  var onDragEnd = React.useCallback(function () {\n    return dispatch(dragEnd());\n  }, [dispatch]);\n  var setData$1 = React.useCallback(function (data) {\n    return dispatch(setData(data));\n  }, [dispatch]);\n  var blur = React.useCallback(function () {\n    return dispatch(blur$1());\n  }, [dispatch]);\n  React.useEffect(function () {\n    var e_1, _a;\n    var prevState = prevStateRef.current;\n    if (state.lastCommit && state.lastCommit !== prevState.lastCommit) {\n      try {\n        for (var _b = __values(state.lastCommit), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var change = _c.value;\n          onCellCommit(change.prevCell, change.nextCell, state.active);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    if (state.data !== prevState.data) {\n      // Call on change only if the data change internal\n      if (state.data !== props.data) {\n        onChange(state.data);\n      }\n    }\n    if (state.mode !== prevState.mode) {\n      onModeChange(state.mode);\n    }\n    if (state.selected !== prevState.selected) {\n      var points = state.selected ? Array.from(iterate(state.selected)) : [];\n      onSelect(points);\n    }\n    if (state.active !== prevState.active) {\n      if (state.active) {\n        onActivate(state.active);\n      } else {\n        var root = rootRef.current;\n        if (root && isFocusedWithin(root) && document.activeElement) {\n          document.activeElement.blur();\n        }\n        onBlur();\n      }\n    }\n    prevStateRef.current = state;\n  }, [props.data, state, onActivate, onBlur, onCellCommit, onChange, onModeChange, onSelect, rowLabels, columnLabels]);\n  React.useEffect(function () {\n    var prevState = prevStateRef.current;\n    if (props.data !== prevState.data) {\n      setData$1(props.data);\n    }\n  }, [props.data, setData$1]);\n  var clip = React.useCallback(function (event) {\n    var data = state.data,\n      selected = state.selected;\n    var csv = getSelectedCSV(selected, data);\n    writeTextToClipboard(event, csv);\n  }, [state]);\n  var handleCut = React.useCallback(function (event) {\n    if (shouldHandleClipboardEvent(rootRef.current, mode)) {\n      event.preventDefault();\n      event.stopPropagation();\n      clip(event);\n      cut$1();\n    }\n  }, [mode, clip, cut$1]);\n  var handleCopy = React.useCallback(function (event) {\n    if (shouldHandleClipboardEvent(rootRef.current, mode)) {\n      event.preventDefault();\n      event.stopPropagation();\n      clip(event);\n      copy$1();\n    }\n  }, [mode, clip, copy$1]);\n  var handlePaste = React.useCallback(function (event) {\n    if (shouldHandleClipboardEvent(rootRef.current, mode)) {\n      event.preventDefault();\n      event.stopPropagation();\n      if (event.clipboardData) {\n        var text = readTextFromClipboard(event);\n        paste$1(text);\n      }\n    }\n  }, [mode, paste$1]);\n  var handleKeyDown = React.useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    // Do not use event in case preventDefault() was called inside onKeyDown\n    if (!event.defaultPrevented) {\n      // Only disable default behavior if an handler exist\n      if (hasKeyDownHandler(state, event)) {\n        event.nativeEvent.preventDefault();\n      }\n      onKeyDownAction(event);\n    }\n  }, [state, onKeyDown, onKeyDownAction]);\n  var handleMouseUp = React.useCallback(function () {\n    onDragEnd();\n    document.removeEventListener(\"mouseup\", handleMouseUp);\n  }, [onDragEnd]);\n  var handleMouseMove = React.useCallback(function (event) {\n    if (!state.dragging && event.buttons === 1) {\n      onDragStart();\n      document.addEventListener(\"mouseup\", handleMouseUp);\n    }\n  }, [state, onDragStart, handleMouseUp]);\n  var handleBlur = React.useCallback(function (event) {\n    var currentTarget = event.currentTarget;\n    setTimeout(function () {\n      if (!isFocusedWithin(currentTarget)) {\n        blur();\n      }\n    }, 0);\n  }, [blur]);\n  var formulaParser = React.useMemo(function () {\n    return props.formulaParser || new Parser();\n  }, [props.formulaParser]);\n  var Cell$1 = React.useMemo(function () {\n    // @ts-ignore\n    return enhance(props.Cell || Cell);\n  }, [props.Cell]);\n  React.useEffect(function () {\n    document.addEventListener(\"cut\", handleCut);\n    document.addEventListener(\"copy\", handleCopy);\n    document.addEventListener(\"paste\", handlePaste);\n    return function () {\n      document.removeEventListener(\"cut\", handleCut);\n      document.removeEventListener(\"copy\", handleCopy);\n      document.removeEventListener(\"paste\", handlePaste);\n    };\n  }, [handleCut, handleCopy, handlePaste]);\n  React.useEffect(function () {\n    formulaParser.on(\"callCellValue\", function (cellCoord, done) {\n      var value;\n      try {\n        var point = transformCoordToPoint(cellCoord);\n        var data = state.data;\n        value = getCellValue(formulaParser, data, point);\n      } catch (error) {\n        console.error(error);\n      } finally {\n        done(value);\n      }\n    });\n    formulaParser.on(\"callRangeValue\", function (startCellCoord, endCellCoord, done) {\n      var startPoint = transformCoordToPoint(startCellCoord);\n      var endPoint = transformCoordToPoint(endCellCoord);\n      var data = state.data;\n      var values;\n      try {\n        values = getCellRangeValue(formulaParser, data, startPoint, endPoint);\n      } catch (error) {\n        console.error(error);\n      } finally {\n        done(values);\n      }\n    });\n  }, [formulaParser, state, handleCut, handleCopy, handlePaste]);\n  var tableNode = React.useMemo(function () {\n    return React.createElement(Table$1, {\n      columns: size.columns,\n      hideColumnIndicators: hideColumnIndicators\n    }, React.createElement(HeaderRow$1, null, !hideRowIndicators && !hideColumnIndicators && React.createElement(CornerIndicator$1, null), !hideColumnIndicators && range(size.columns).map(function (columnNumber) {\n      return columnLabels ? React.createElement(ColumnIndicator$1, {\n        key: columnNumber,\n        column: columnNumber,\n        label: columnNumber in columnLabels ? columnLabels[columnNumber] : null\n      }) : React.createElement(ColumnIndicator$1, {\n        key: columnNumber,\n        column: columnNumber\n      });\n    })), range(size.rows).map(function (rowNumber) {\n      return React.createElement(Row$1, {\n        key: rowNumber,\n        row: rowNumber\n      }, !hideRowIndicators && (rowLabels ? React.createElement(RowIndicator$1, {\n        key: rowNumber,\n        row: rowNumber,\n        label: rowNumber in rowLabels ? rowLabels[rowNumber] : null\n      }) : React.createElement(RowIndicator$1, {\n        key: rowNumber,\n        row: rowNumber\n      })), range(size.columns).map(function (columnNumber) {\n        return React.createElement(Cell$1, {\n          key: columnNumber,\n          row: rowNumber,\n          column: columnNumber,\n          // @ts-ignore\n          DataViewer: DataViewer$1,\n          formulaParser: formulaParser\n        });\n      }));\n    }));\n  }, [Table$1, size.rows, size.columns, hideColumnIndicators, Row$1, HeaderRow$1, hideRowIndicators, CornerIndicator$1, columnLabels, ColumnIndicator$1, rowLabels, RowIndicator$1, Cell$1, DataViewer$1, formulaParser]);\n  var activeCellNode = React.useMemo(function () {\n    return React.createElement(ActiveCell\n    // @ts-ignore\n    , {\n      // @ts-ignore\n      DataEditor: DataEditor$1,\n      // @ts-ignore\n      getBindingsForCell: getBindingsForCell$1\n    });\n  }, [DataEditor$1, getBindingsForCell$1]);\n  var rootNode = React.useMemo(function () {\n    return React.createElement(\"div\", {\n      ref: rootRef,\n      className: classnames(\"Spreadsheet\", className, {\n        \"Spreadsheet--dark-mode\": darkMode\n      }),\n      onKeyPress: onKeyPress,\n      onKeyDown: handleKeyDown,\n      onMouseMove: handleMouseMove,\n      onBlur: handleBlur\n    }, tableNode, activeCellNode, React.createElement(Selected, null), React.createElement(Copied, null));\n  }, [className, darkMode, onKeyPress, handleKeyDown, handleMouseMove, handleBlur, tableNode, activeCellNode]);\n  return React.createElement(context.Provider, {\n    value: reducerElements\n  }, rootNode);\n};\nexport { DataEditor, DataViewer, Spreadsheet, createEmpty as createEmptyMatrix, Spreadsheet as default, getComputedValue };","map":{"version":3,"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode"],"sources":["D:\\WebNodeJs\\node18\\trelo_project\\front_end\\node_modules\\react-spreadsheet\\node_modules\\style-inject\\dist\\style-inject.es.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAWA,CAACC,GAAG,EAAEC,GAAG,EAAE;EAC7B,IAAKA,GAAG,KAAK,KAAK,CAAC,EAAGA,GAAG,GAAG,EAAE;EAC9B,IAAIC,QAAQ,GAAGD,GAAG,CAACC,QAAQ;EAE3B,IAAI,CAACF,GAAG,IAAI,OAAOG,QAAQ,KAAK,WAAW,EAAE;IAAE;EAAO;EAEtD,IAAIC,IAAI,GAAGD,QAAQ,CAACC,IAAI,IAAID,QAAQ,CAACE,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;EACpE,IAAIC,KAAK,GAAGH,QAAQ,CAACI,aAAa,CAAC,OAAO,CAAC;EAC3CD,KAAK,CAACE,IAAI,GAAG,UAAU;EAEvB,IAAIN,QAAQ,KAAK,KAAK,EAAE;IACtB,IAAIE,IAAI,CAACK,UAAU,EAAE;MACnBL,IAAI,CAACM,YAAY,CAACJ,KAAK,EAAEF,IAAI,CAACK,UAAU,CAAC;IAC/C,CAAK,MAAM;MACLL,IAAI,CAACO,WAAW,CAACL,KAAK,CAAC;IAC7B;EACA,CAAG,MAAM;IACLF,IAAI,CAACO,WAAW,CAACL,KAAK,CAAC;EAC3B;EAEE,IAAIA,KAAK,CAACM,UAAU,EAAE;IACpBN,KAAK,CAACM,UAAU,CAACC,OAAO,GAAGb,GAAG;EAClC,CAAG,MAAM;IACLM,KAAK,CAACK,WAAW,CAACR,QAAQ,CAACW,cAAc,CAACd,GAAG,CAAC,CAAC;EACnD;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}