{"ast":null,"code":"var error = require('./utils/error');\nvar dateTime = require('./date-time');\nvar utils = require('./utils/common');\nfunction validDate(d) {\n  return d && d.getTime && !isNaN(d.getTime());\n}\nfunction ensureDate(d) {\n  return d instanceof Date ? d : new Date(d);\n}\nexports.ACCRINT = function (issue, first, settlement, rate, par, frequency, basis) {\n  // Return error if either date is invalid\n  issue = ensureDate(issue);\n  first = ensureDate(first);\n  settlement = ensureDate(settlement);\n  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {\n    return error.value;\n  }\n\n  // Return error if either rate or par are lower than or equal to zero\n  if (rate <= 0 || par <= 0) {\n    return error.num;\n  }\n\n  // Return error if frequency is neither 1, 2, or 4\n  if ([1, 2, 4].indexOf(frequency) === -1) {\n    return error.num;\n  }\n\n  // Return error if basis is neither 0, 1, 2, 3, or 4\n  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {\n    return error.num;\n  }\n\n  // Return error if settlement is before or equal to issue\n  if (settlement <= issue) {\n    return error.num;\n  }\n\n  // Set default values\n  par = par || 0;\n  basis = basis || 0;\n\n  // Compute accrued interest\n  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);\n};\n\n// TODO\nexports.ACCRINTM = function () {\n  throw new Error('ACCRINTM is not implemented');\n};\n\n// TODO\nexports.AMORDEGRC = function () {\n  throw new Error('AMORDEGRC is not implemented');\n};\n\n// TODO\nexports.AMORLINC = function () {\n  throw new Error('AMORLINC is not implemented');\n};\n\n// TODO\nexports.COUPDAYBS = function () {\n  throw new Error('COUPDAYBS is not implemented');\n};\n\n// TODO\nexports.COUPDAYS = function () {\n  throw new Error('COUPDAYS is not implemented');\n};\n\n// TODO\nexports.COUPDAYSNC = function () {\n  throw new Error('COUPDAYSNC is not implemented');\n};\n\n// TODO\nexports.COUPNCD = function () {\n  throw new Error('COUPNCD is not implemented');\n};\n\n// TODO\nexports.COUPNUM = function () {\n  throw new Error('COUPNUM is not implemented');\n};\n\n// TODO\nexports.COUPPCD = function () {\n  throw new Error('COUPPCD is not implemented');\n};\nexports.CUMIPMT = function (rate, periods, value, start, end, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n  // Credits: Hannes Stiebitzhofer for the translations of function and variable names\n  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  value = utils.parseNumber(value);\n  if (utils.anyIsError(rate, periods, value)) {\n    return error.value;\n  }\n\n  // Return error if either rate, periods, or value are lower than or equal to zero\n  if (rate <= 0 || periods <= 0 || value <= 0) {\n    return error.num;\n  }\n\n  // Return error if start < 1, end < 1, or start > end\n  if (start < 1 || end < 1 || start > end) {\n    return error.num;\n  }\n\n  // Return error if type is neither 0 nor 1\n  if (type !== 0 && type !== 1) {\n    return error.num;\n  }\n\n  // Compute cumulative interest\n  var payment = exports.PMT(rate, periods, value, 0, type);\n  var interest = 0;\n  if (start === 1) {\n    if (type === 0) {\n      interest = -value;\n      start++;\n    }\n  }\n  for (var i = start; i <= end; i++) {\n    if (type === 1) {\n      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;\n    } else {\n      interest += exports.FV(rate, i - 1, payment, value, 0);\n    }\n  }\n  interest *= rate;\n\n  // Return cumulative interest\n  return interest;\n};\nexports.CUMPRINC = function (rate, periods, value, start, end, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n  // Credits: Hannes Stiebitzhofer for the translations of function and variable names\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  value = utils.parseNumber(value);\n  if (utils.anyIsError(rate, periods, value)) {\n    return error.value;\n  }\n\n  // Return error if either rate, periods, or value are lower than or equal to zero\n  if (rate <= 0 || periods <= 0 || value <= 0) {\n    return error.num;\n  }\n\n  // Return error if start < 1, end < 1, or start > end\n  if (start < 1 || end < 1 || start > end) {\n    return error.num;\n  }\n\n  // Return error if type is neither 0 nor 1\n  if (type !== 0 && type !== 1) {\n    return error.num;\n  }\n\n  // Compute cumulative principal\n  var payment = exports.PMT(rate, periods, value, 0, type);\n  var principal = 0;\n  if (start === 1) {\n    if (type === 0) {\n      principal = payment + value * rate;\n    } else {\n      principal = payment;\n    }\n    start++;\n  }\n  for (var i = start; i <= end; i++) {\n    if (type > 0) {\n      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;\n    } else {\n      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;\n    }\n  }\n\n  // Return cumulative principal\n  return principal;\n};\nexports.DB = function (cost, salvage, life, period, month) {\n  // Initialize month\n  month = month === undefined ? 12 : month;\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  period = utils.parseNumber(period);\n  month = utils.parseNumber(month);\n  if (utils.anyIsError(cost, salvage, life, period, month)) {\n    return error.value;\n  }\n\n  // Return error if any of the parameters is negative\n  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {\n    return error.num;\n  }\n\n  // Return error if month is not an integer between 1 and 12\n  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {\n    return error.num;\n  }\n\n  // Return error if period is greater than life\n  if (period > life) {\n    return error.num;\n  }\n\n  // Return 0 (zero) if salvage is greater than or equal to cost\n  if (salvage >= cost) {\n    return 0;\n  }\n\n  // Rate is rounded to three decimals places\n  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);\n\n  // Compute initial depreciation\n  var initial = cost * rate * month / 12;\n\n  // Compute total depreciation\n  var total = initial;\n  var current = 0;\n  var ceiling = period === life ? life - 1 : period;\n  for (var i = 2; i <= ceiling; i++) {\n    current = (cost - total) * rate;\n    total += current;\n  }\n\n  // Depreciation for the first and last periods are special cases\n  if (period === 1) {\n    // First period\n    return initial;\n  } else if (period === life) {\n    // Last period\n    return (cost - total) * rate;\n  } else {\n    return current;\n  }\n};\nexports.DDB = function (cost, salvage, life, period, factor) {\n  // Initialize factor\n  factor = factor === undefined ? 2 : factor;\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  period = utils.parseNumber(period);\n  factor = utils.parseNumber(factor);\n  if (utils.anyIsError(cost, salvage, life, period, factor)) {\n    return error.value;\n  }\n\n  // Return error if any of the parameters is negative or if factor is null\n  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {\n    return error.num;\n  }\n\n  // Return error if period is greater than life\n  if (period > life) {\n    return error.num;\n  }\n\n  // Return 0 (zero) if salvage is greater than or equal to cost\n  if (salvage >= cost) {\n    return 0;\n  }\n\n  // Compute depreciation\n  var total = 0;\n  var current = 0;\n  for (var i = 1; i <= period; i++) {\n    current = Math.min((cost - total) * (factor / life), cost - salvage - total);\n    total += current;\n  }\n\n  // Return depreciation\n  return current;\n};\n\n// TODO\nexports.DISC = function () {\n  throw new Error('DISC is not implemented');\n};\nexports.DOLLARDE = function (dollar, fraction) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  dollar = utils.parseNumber(dollar);\n  fraction = utils.parseNumber(fraction);\n  if (utils.anyIsError(dollar, fraction)) {\n    return error.value;\n  }\n\n  // Return error if fraction is negative\n  if (fraction < 0) {\n    return error.num;\n  }\n\n  // Return error if fraction is greater than or equal to 0 and less than 1\n  if (fraction >= 0 && fraction < 1) {\n    return error.div0;\n  }\n\n  // Truncate fraction if it is not an integer\n  fraction = parseInt(fraction, 10);\n\n  // Compute integer part\n  var result = parseInt(dollar, 10);\n\n  // Add decimal part\n  result += dollar % 1 * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;\n\n  // Round result\n  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);\n  result = Math.round(result * power) / power;\n\n  // Return converted dollar price\n  return result;\n};\nexports.DOLLARFR = function (dollar, fraction) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  dollar = utils.parseNumber(dollar);\n  fraction = utils.parseNumber(fraction);\n  if (utils.anyIsError(dollar, fraction)) {\n    return error.value;\n  }\n\n  // Return error if fraction is negative\n  if (fraction < 0) {\n    return error.num;\n  }\n\n  // Return error if fraction is greater than or equal to 0 and less than 1\n  if (fraction >= 0 && fraction < 1) {\n    return error.div0;\n  }\n\n  // Truncate fraction if it is not an integer\n  fraction = parseInt(fraction, 10);\n\n  // Compute integer part\n  var result = parseInt(dollar, 10);\n\n  // Add decimal part\n  result += dollar % 1 * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;\n\n  // Return converted dollar price\n  return result;\n};\n\n// TODO\nexports.DURATION = function () {\n  throw new Error('DURATION is not implemented');\n};\nexports.EFFECT = function (rate, periods) {\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  if (utils.anyIsError(rate, periods)) {\n    return error.value;\n  }\n\n  // Return error if rate <=0 or periods < 1\n  if (rate <= 0 || periods < 1) {\n    return error.num;\n  }\n\n  // Truncate periods if it is not an integer\n  periods = parseInt(periods, 10);\n\n  // Return effective annual interest rate\n  return Math.pow(1 + rate / periods, periods) - 1;\n};\nexports.FV = function (rate, periods, payment, value, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  value = value || 0;\n  type = type || 0;\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  payment = utils.parseNumber(payment);\n  value = utils.parseNumber(value);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, payment, value, type)) {\n    return error.value;\n  }\n\n  // Return future value\n  var result;\n  if (rate === 0) {\n    result = value + payment * periods;\n  } else {\n    var term = Math.pow(1 + rate, periods);\n    if (type === 1) {\n      result = value * term + payment * (1 + rate) * (term - 1) / rate;\n    } else {\n      result = value * term + payment * (term - 1) / rate;\n    }\n  }\n  return -result;\n};\nexports.FVSCHEDULE = function (principal, schedule) {\n  principal = utils.parseNumber(principal);\n  schedule = utils.parseNumberArray(utils.flatten(schedule));\n  if (utils.anyIsError(principal, schedule)) {\n    return error.value;\n  }\n  var n = schedule.length;\n  var future = principal;\n\n  // Apply all interests in schedule\n  for (var i = 0; i < n; i++) {\n    // Apply scheduled interest\n    future *= 1 + schedule[i];\n  }\n\n  // Return future value\n  return future;\n};\n\n// TODO\nexports.INTRATE = function () {\n  throw new Error('INTRATE is not implemented');\n};\nexports.IPMT = function (rate, period, periods, present, future, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  future = future || 0;\n  type = type || 0;\n  rate = utils.parseNumber(rate);\n  period = utils.parseNumber(period);\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, period, periods, present, future, type)) {\n    return error.value;\n  }\n\n  // Compute payment\n  var payment = exports.PMT(rate, periods, present, future, type);\n\n  // Compute interest\n  var interest;\n  if (period === 1) {\n    if (type === 1) {\n      interest = 0;\n    } else {\n      interest = -present;\n    }\n  } else {\n    if (type === 1) {\n      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;\n    } else {\n      interest = exports.FV(rate, period - 1, payment, present, 0);\n    }\n  }\n\n  // Return interest\n  return interest * rate;\n};\nexports.IRR = function (values, guess) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  guess = guess || 0;\n  values = utils.parseNumberArray(utils.flatten(values));\n  guess = utils.parseNumber(guess);\n  if (utils.anyIsError(values, guess)) {\n    return error.value;\n  }\n\n  // Calculates the resulting amount\n  var irrResult = function (values, dates, rate) {\n    var r = rate + 1;\n    var result = values[0];\n    for (var i = 1; i < values.length; i++) {\n      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);\n    }\n    return result;\n  };\n\n  // Calculates the first derivation\n  var irrResultDeriv = function (values, dates, rate) {\n    var r = rate + 1;\n    var result = 0;\n    for (var i = 1; i < values.length; i++) {\n      var frac = (dates[i] - dates[0]) / 365;\n      result -= frac * values[i] / Math.pow(r, frac + 1);\n    }\n    return result;\n  };\n\n  // Initialize dates and check that values contains at least one positive value and one negative value\n  var dates = [];\n  var positive = false;\n  var negative = false;\n  for (var i = 0; i < values.length; i++) {\n    dates[i] = i === 0 ? 0 : dates[i - 1] + 365;\n    if (values[i] > 0) {\n      positive = true;\n    }\n    if (values[i] < 0) {\n      negative = true;\n    }\n  }\n\n  // Return error if values does not contain at least one positive value and one negative value\n  if (!positive || !negative) {\n    return error.num;\n  }\n\n  // Initialize guess and resultRate\n  guess = guess === undefined ? 0.1 : guess;\n  var resultRate = guess;\n\n  // Set maximum epsilon for end of iteration\n  var epsMax = 1e-10;\n\n  // Implement Newton's method\n  var newRate, epsRate, resultValue;\n  var contLoop = true;\n  do {\n    resultValue = irrResult(values, dates, resultRate);\n    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);\n    epsRate = Math.abs(newRate - resultRate);\n    resultRate = newRate;\n    contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;\n  } while (contLoop);\n\n  // Return internal rate of return\n  return resultRate;\n};\nexports.ISPMT = function (rate, period, periods, value) {\n  rate = utils.parseNumber(rate);\n  period = utils.parseNumber(period);\n  periods = utils.parseNumber(periods);\n  value = utils.parseNumber(value);\n  if (utils.anyIsError(rate, period, periods, value)) {\n    return error.value;\n  }\n\n  // Return interest\n  return value * rate * (period / periods - 1);\n};\n\n// TODO\nexports.MDURATION = function () {\n  throw new Error('MDURATION is not implemented');\n};\nexports.MIRR = function (values, finance_rate, reinvest_rate) {\n  values = utils.parseNumberArray(utils.flatten(values));\n  finance_rate = utils.parseNumber(finance_rate);\n  reinvest_rate = utils.parseNumber(reinvest_rate);\n  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {\n    return error.value;\n  }\n\n  // Initialize number of values\n  var n = values.length;\n\n  // Lookup payments (negative values) and incomes (positive values)\n  var payments = [];\n  var incomes = [];\n  for (var i = 0; i < n; i++) {\n    if (values[i] < 0) {\n      payments.push(values[i]);\n    } else {\n      incomes.push(values[i]);\n    }\n  }\n\n  // Return modified internal rate of return\n  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);\n  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);\n  return Math.pow(num / den, 1 / (n - 1)) - 1;\n};\nexports.NOMINAL = function (rate, periods) {\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  if (utils.anyIsError(rate, periods)) {\n    return error.value;\n  }\n\n  // Return error if rate <=0 or periods < 1\n  if (rate <= 0 || periods < 1) {\n    return error.num;\n  }\n\n  // Truncate periods if it is not an integer\n  periods = parseInt(periods, 10);\n\n  // Return nominal annual interest rate\n  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;\n};\nexports.NPER = function (rate, payment, present, future, type) {\n  type = type === undefined ? 0 : type;\n  future = future === undefined ? 0 : future;\n  rate = utils.parseNumber(rate);\n  payment = utils.parseNumber(payment);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, payment, present, future, type)) {\n    return error.value;\n  }\n\n  // Return number of periods\n  var num = payment * (1 + rate * type) - future * rate;\n  var den = present * rate + payment * (1 + rate * type);\n  return Math.log(num / den) / Math.log(1 + rate);\n};\nexports.NPV = function () {\n  var args = utils.parseNumberArray(utils.flatten(arguments));\n  if (args instanceof Error) {\n    return args;\n  }\n\n  // Lookup rate\n  var rate = args[0];\n\n  // Initialize net present value\n  var value = 0;\n\n  // Loop on all values\n  for (var j = 1; j < args.length; j++) {\n    value += args[j] / Math.pow(1 + rate, j);\n  }\n\n  // Return net present value\n  return value;\n};\n\n// TODO\nexports.ODDFPRICE = function () {\n  throw new Error('ODDFPRICE is not implemented');\n};\n\n// TODO\nexports.ODDFYIELD = function () {\n  throw new Error('ODDFYIELD is not implemented');\n};\n\n// TODO\nexports.ODDLPRICE = function () {\n  throw new Error('ODDLPRICE is not implemented');\n};\n\n// TODO\nexports.ODDLYIELD = function () {\n  throw new Error('ODDLYIELD is not implemented');\n};\nexports.PDURATION = function (rate, present, future) {\n  rate = utils.parseNumber(rate);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  if (utils.anyIsError(rate, present, future)) {\n    return error.value;\n  }\n\n  // Return error if rate <=0\n  if (rate <= 0) {\n    return error.num;\n  }\n\n  // Return number of periods\n  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);\n};\nexports.PMT = function (rate, periods, present, future, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  future = future || 0;\n  type = type || 0;\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, present, future, type)) {\n    return error.value;\n  }\n\n  // Return payment\n  var result;\n  if (rate === 0) {\n    result = (present + future) / periods;\n  } else {\n    var term = Math.pow(1 + rate, periods);\n    if (type === 1) {\n      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);\n    } else {\n      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);\n    }\n  }\n  return -result;\n};\nexports.PPMT = function (rate, period, periods, present, future, type) {\n  future = future || 0;\n  type = type || 0;\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, present, future, type)) {\n    return error.value;\n  }\n  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);\n};\n\n// TODO\nexports.PRICE = function () {\n  throw new Error('PRICE is not implemented');\n};\n\n// TODO\nexports.PRICEDISC = function () {\n  throw new Error('PRICEDISC is not implemented');\n};\n\n// TODO\nexports.PRICEMAT = function () {\n  throw new Error('PRICEMAT is not implemented');\n};\nexports.PV = function (rate, periods, payment, future, type) {\n  future = future || 0;\n  type = type || 0;\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  payment = utils.parseNumber(payment);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, payment, future, type)) {\n    return error.value;\n  }\n\n  // Return present value\n  if (rate === 0) {\n    return -payment * periods - future;\n  } else {\n    return ((1 - Math.pow(1 + rate, periods)) / rate * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);\n  }\n};\nexports.RATE = function (periods, payment, present, future, type, guess) {\n  // Credits: rabugento\n\n  guess = guess === undefined ? 0.01 : guess;\n  future = future === undefined ? 0 : future;\n  type = type === undefined ? 0 : type;\n  periods = utils.parseNumber(periods);\n  payment = utils.parseNumber(payment);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  guess = utils.parseNumber(guess);\n  if (utils.anyIsError(periods, payment, present, future, type, guess)) {\n    return error.value;\n  }\n\n  // Set maximum epsilon for end of iteration\n  var epsMax = 1e-10;\n\n  // Set maximum number of iterations\n  var iterMax = 50;\n\n  // Implement Newton's method\n  var y,\n    y0,\n    y1,\n    x0,\n    x1 = 0,\n    f = 0,\n    i = 0;\n  var rate = guess;\n  if (Math.abs(rate) < epsMax) {\n    y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\n  } else {\n    f = Math.exp(periods * Math.log(1 + rate));\n    y = present * f + payment * (1 / rate + type) * (f - 1) + future;\n  }\n  y0 = present + payment * periods + future;\n  y1 = present * f + payment * (1 / rate + type) * (f - 1) + future;\n  i = x0 = 0;\n  x1 = rate;\n  while (Math.abs(y0 - y1) > epsMax && i < iterMax) {\n    rate = (y1 * x0 - y0 * x1) / (y1 - y0);\n    x0 = x1;\n    x1 = rate;\n    if (Math.abs(rate) < epsMax) {\n      y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\n    } else {\n      f = Math.exp(periods * Math.log(1 + rate));\n      y = present * f + payment * (1 / rate + type) * (f - 1) + future;\n    }\n    y0 = y1;\n    y1 = y;\n    ++i;\n  }\n  return rate;\n};\n\n// TODO\nexports.RECEIVED = function () {\n  throw new Error('RECEIVED is not implemented');\n};\nexports.RRI = function (periods, present, future) {\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  if (utils.anyIsError(periods, present, future)) {\n    return error.value;\n  }\n\n  // Return error if periods or present is equal to 0 (zero)\n  if (periods === 0 || present === 0) {\n    return error.num;\n  }\n\n  // Return equivalent interest rate\n  return Math.pow(future / present, 1 / periods) - 1;\n};\nexports.SLN = function (cost, salvage, life) {\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  if (utils.anyIsError(cost, salvage, life)) {\n    return error.value;\n  }\n\n  // Return error if life equal to 0 (zero)\n  if (life === 0) {\n    return error.num;\n  }\n\n  // Return straight-line depreciation\n  return (cost - salvage) / life;\n};\nexports.SYD = function (cost, salvage, life, period) {\n  // Return error if any of the parameters is not a number\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  period = utils.parseNumber(period);\n  if (utils.anyIsError(cost, salvage, life, period)) {\n    return error.value;\n  }\n\n  // Return error if life equal to 0 (zero)\n  if (life === 0) {\n    return error.num;\n  }\n\n  // Return error if period is lower than 1 or greater than life\n  if (period < 1 || period > life) {\n    return error.num;\n  }\n\n  // Truncate period if it is not an integer\n  period = parseInt(period, 10);\n\n  // Return straight-line depreciation\n  return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));\n};\nexports.TBILLEQ = function (settlement, maturity, discount) {\n  settlement = utils.parseDate(settlement);\n  maturity = utils.parseDate(maturity);\n  discount = utils.parseNumber(discount);\n  if (utils.anyIsError(settlement, maturity, discount)) {\n    return error.value;\n  }\n\n  // Return error if discount is lower than or equal to zero\n  if (discount <= 0) {\n    return error.num;\n  }\n\n  // Return error if settlement is greater than maturity\n  if (settlement > maturity) {\n    return error.num;\n  }\n\n  // Return error if maturity is more than one year after settlement\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\n    return error.num;\n  }\n\n  // Return bond-equivalent yield\n  return 365 * discount / (360 - discount * dateTime.DAYS360(settlement, maturity, false));\n};\nexports.TBILLPRICE = function (settlement, maturity, discount) {\n  settlement = utils.parseDate(settlement);\n  maturity = utils.parseDate(maturity);\n  discount = utils.parseNumber(discount);\n  if (utils.anyIsError(settlement, maturity, discount)) {\n    return error.value;\n  }\n\n  // Return error if discount is lower than or equal to zero\n  if (discount <= 0) {\n    return error.num;\n  }\n\n  // Return error if settlement is greater than maturity\n  if (settlement > maturity) {\n    return error.num;\n  }\n\n  // Return error if maturity is more than one year after settlement\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\n    return error.num;\n  }\n\n  // Return bond-equivalent yield\n  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);\n};\nexports.TBILLYIELD = function (settlement, maturity, price) {\n  settlement = utils.parseDate(settlement);\n  maturity = utils.parseDate(maturity);\n  price = utils.parseNumber(price);\n  if (utils.anyIsError(settlement, maturity, price)) {\n    return error.value;\n  }\n\n  // Return error if price is lower than or equal to zero\n  if (price <= 0) {\n    return error.num;\n  }\n\n  // Return error if settlement is greater than maturity\n  if (settlement > maturity) {\n    return error.num;\n  }\n\n  // Return error if maturity is more than one year after settlement\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\n    return error.num;\n  }\n\n  // Return bond-equivalent yield\n  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));\n};\n\n// TODO\nexports.VDB = function () {\n  throw new Error('VDB is not implemented');\n};\n\n// TODO needs better support for date\n// exports.XIRR = function(values, dates, guess) {\n//   // Credits: algorithm inspired by Apache OpenOffice\n//\n//   values = utils.parseNumberArray(utils.flatten(values));\n//   dates = utils.parseDateArray(utils.flatten(dates));\n//   guess = utils.parseNumber(guess);\n//\n//   if (utils.anyIsError(values, dates, guess)) {\n//     return error.value;\n//   }\n//\n//   // Calculates the resulting amount\n//   var irrResult = function(values, dates, rate) {\n//     var r = rate + 1;\n//     var result = values[0];\n//     for (var i = 1; i < values.length; i++) {\n//       result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);\n//     }\n//     return result;\n//   };\n//\n//   // Calculates the first derivation\n//   var irrResultDeriv = function(values, dates, rate) {\n//     var r = rate + 1;\n//     var result = 0;\n//     for (var i = 1; i < values.length; i++) {\n//       var frac = dateTime.DAYS(dates[i], dates[0]) / 365;\n//       result -= frac * values[i] / Math.pow(r, frac + 1);\n//     }\n//     return result;\n//   };\n//\n//   // Check that values contains at least one positive value and one negative value\n//   var positive = false;\n//   var negative = false;\n//   for (var i = 0; i < values.length; i++) {\n//     if (values[i] > 0) {\n//       positive = true;\n//     }\n//     if (values[i] < 0) {\n//       negative = true;\n//     }\n//   }\n//\n//   // Return error if values does not contain at least one positive value and one negative value\n//   if (!positive || !negative) {\n//     return error.num;\n//   }\n//\n//   // Initialize guess and resultRate\n//   guess = guess || 0.1;\n//   var resultRate = guess;\n//\n//   // Set maximum epsilon for end of iteration\n//   var epsMax = 1e-10;\n//\n//   // Implement Newton's method\n//   var newRate, epsRate, resultValue;\n//   var contLoop = true;\n//   do {\n//     resultValue = irrResult(values, dates, resultRate);\n//     newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);\n//     epsRate = Math.abs(newRate - resultRate);\n//     resultRate = newRate;\n//     contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);\n//   } while (contLoop);\n//\n//   // Return internal rate of return\n//   return resultRate;\n// };\n\nexports.XNPV = function (rate, values, dates) {\n  rate = utils.parseNumber(rate);\n  values = utils.parseNumberArray(utils.flatten(values));\n  dates = utils.parseDateArray(utils.flatten(dates));\n  if (utils.anyIsError(rate, values, dates)) {\n    return error.value;\n  }\n  var result = 0;\n  for (var i = 0; i < values.length; i++) {\n    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);\n  }\n  return result;\n};\n\n// TODO\nexports.YIELD = function () {\n  throw new Error('YIELD is not implemented');\n};\n\n// TODO\nexports.YIELDDISC = function () {\n  throw new Error('YIELDDISC is not implemented');\n};\n\n// TODO\nexports.YIELDMAT = function () {\n  throw new Error('YIELDMAT is not implemented');\n};","map":{"version":3,"names":["error","require","dateTime","utils","validDate","d","getTime","isNaN","ensureDate","Date","exports","ACCRINT","issue","first","settlement","rate","par","frequency","basis","value","num","indexOf","YEARFRAC","ACCRINTM","Error","AMORDEGRC","AMORLINC","COUPDAYBS","COUPDAYS","COUPDAYSNC","COUPNCD","COUPNUM","COUPPCD","CUMIPMT","periods","start","end","type","parseNumber","anyIsError","payment","PMT","interest","i","FV","CUMPRINC","principal","DB","cost","salvage","life","period","month","undefined","Math","pow","toFixed","initial","total","current","ceiling","DDB","factor","min","DISC","DOLLARDE","dollar","fraction","div0","parseInt","result","ceil","log","LN10","power","LN2","round","DOLLARFR","DURATION","EFFECT","term","FVSCHEDULE","schedule","parseNumberArray","flatten","n","length","future","INTRATE","IPMT","present","IRR","values","guess","irrResult","dates","r","irrResultDeriv","frac","positive","negative","resultRate","epsMax","newRate","epsRate","resultValue","contLoop","abs","ISPMT","MDURATION","MIRR","finance_rate","reinvest_rate","payments","incomes","push","NPV","den","NOMINAL","NPER","args","arguments","j","ODDFPRICE","ODDFYIELD","ODDLPRICE","ODDLYIELD","PDURATION","PPMT","PRICE","PRICEDISC","PRICEMAT","PV","RATE","iterMax","y","y0","y1","x0","x1","f","exp","RECEIVED","RRI","SLN","SYD","TBILLEQ","maturity","discount","parseDate","DAYS360","TBILLPRICE","TBILLYIELD","price","VDB","XNPV","parseDateArray","DAYS","YIELD","YIELDDISC","YIELDMAT"],"sources":["D:/WebNodeJs/node18/trelo_project/front_end/node_modules/@handsontable/formulajs/lib/financial.js"],"sourcesContent":["var error = require('./utils/error');\nvar dateTime = require('./date-time');\nvar utils = require('./utils/common');\n\nfunction validDate(d) {\n  return d && d.getTime && !isNaN(d.getTime());\n}\n\nfunction ensureDate(d) {\n  return (d instanceof Date)?d:new Date(d);\n}\n\nexports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {\n  // Return error if either date is invalid\n  issue      = ensureDate(issue);\n  first      = ensureDate(first);\n  settlement = ensureDate(settlement);\n  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {\n    return error.value;\n  }\n\n  // Return error if either rate or par are lower than or equal to zero\n  if (rate <= 0 || par <= 0) {\n    return error.num;\n  }\n\n  // Return error if frequency is neither 1, 2, or 4\n  if ([1, 2, 4].indexOf(frequency) === -1) {\n    return error.num;\n  }\n\n  // Return error if basis is neither 0, 1, 2, 3, or 4\n  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {\n    return error.num;\n  }\n\n  // Return error if settlement is before or equal to issue\n  if (settlement <= issue) {\n    return error.num;\n  }\n\n  // Set default values\n  par   = par   || 0;\n  basis = basis || 0;\n\n  // Compute accrued interest\n  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);\n};\n\n// TODO\nexports.ACCRINTM = function() {\n  throw new Error('ACCRINTM is not implemented');\n};\n\n// TODO\nexports.AMORDEGRC = function() {\n  throw new Error('AMORDEGRC is not implemented');\n};\n\n// TODO\nexports.AMORLINC = function() {\n  throw new Error('AMORLINC is not implemented');\n};\n\n// TODO\nexports.COUPDAYBS = function() {\n  throw new Error('COUPDAYBS is not implemented');\n};\n\n// TODO\nexports.COUPDAYS = function() {\n  throw new Error('COUPDAYS is not implemented');\n};\n\n// TODO\nexports.COUPDAYSNC = function() {\n  throw new Error('COUPDAYSNC is not implemented');\n};\n\n// TODO\nexports.COUPNCD = function() {\n  throw new Error('COUPNCD is not implemented');\n};\n\n// TODO\nexports.COUPNUM = function() {\n  throw new Error('COUPNUM is not implemented');\n};\n\n// TODO\nexports.COUPPCD = function() {\n  throw new Error('COUPPCD is not implemented');\n};\n\nexports.CUMIPMT = function(rate, periods, value, start, end, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n  // Credits: Hannes Stiebitzhofer for the translations of function and variable names\n  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  value = utils.parseNumber(value);\n  if (utils.anyIsError(rate, periods, value)) {\n    return error.value;\n  }\n\n  // Return error if either rate, periods, or value are lower than or equal to zero\n  if (rate <= 0 || periods <= 0 || value <= 0) {\n    return error.num;\n  }\n\n  // Return error if start < 1, end < 1, or start > end\n  if (start < 1 || end < 1 || start > end) {\n    return error.num;\n  }\n\n  // Return error if type is neither 0 nor 1\n  if (type !== 0 && type !== 1) {\n    return error.num;\n  }\n\n  // Compute cumulative interest\n  var payment = exports.PMT(rate, periods, value, 0, type);\n  var interest = 0;\n\n  if (start === 1) {\n    if (type === 0) {\n      interest = -value;\n      start++;\n    }\n  }\n\n  for (var i = start; i <= end; i++) {\n    if (type === 1) {\n      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;\n    } else {\n      interest += exports.FV(rate, i - 1, payment, value, 0);\n    }\n  }\n  interest *= rate;\n\n  // Return cumulative interest\n  return interest;\n};\n\nexports.CUMPRINC = function(rate, periods, value, start, end, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n  // Credits: Hannes Stiebitzhofer for the translations of function and variable names\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  value = utils.parseNumber(value);\n  if (utils.anyIsError(rate, periods, value)) {\n    return error.value;\n  }\n\n  // Return error if either rate, periods, or value are lower than or equal to zero\n  if (rate <= 0 || periods <= 0 || value <= 0) {\n    return error.num;\n  }\n\n  // Return error if start < 1, end < 1, or start > end\n  if (start < 1 || end < 1 || start > end) {\n    return error.num;\n  }\n\n  // Return error if type is neither 0 nor 1\n  if (type !== 0 && type !== 1) {\n    return error.num;\n  }\n\n  // Compute cumulative principal\n  var payment = exports.PMT(rate, periods, value, 0, type);\n  var principal = 0;\n  if (start === 1) {\n    if (type === 0) {\n      principal = payment + value * rate;\n    } else {\n      principal = payment;\n    }\n    start++;\n  }\n  for (var i = start; i <= end; i++) {\n    if (type > 0) {\n      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;\n    } else {\n      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;\n    }\n  }\n\n  // Return cumulative principal\n  return principal;\n};\n\nexports.DB = function(cost, salvage, life, period, month) {\n  // Initialize month\n  month = (month === undefined) ? 12 : month;\n\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  period = utils.parseNumber(period);\n  month = utils.parseNumber(month);\n  if (utils.anyIsError(cost, salvage, life, period, month)) {\n    return error.value;\n  }\n\n  // Return error if any of the parameters is negative\n  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {\n    return error.num;\n  }\n\n  // Return error if month is not an integer between 1 and 12\n  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {\n    return error.num;\n  }\n\n  // Return error if period is greater than life\n  if (period > life) {\n    return error.num;\n  }\n\n  // Return 0 (zero) if salvage is greater than or equal to cost\n  if (salvage >= cost) {\n    return 0;\n  }\n\n  // Rate is rounded to three decimals places\n  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);\n\n  // Compute initial depreciation\n  var initial = cost * rate * month / 12;\n\n  // Compute total depreciation\n  var total = initial;\n  var current = 0;\n  var ceiling = (period === life) ? life - 1 : period;\n  for (var i = 2; i <= ceiling; i++) {\n    current = (cost - total) * rate;\n    total += current;\n  }\n\n  // Depreciation for the first and last periods are special cases\n  if (period === 1) {\n    // First period\n    return initial;\n  } else if (period === life) {\n    // Last period\n    return (cost - total) * rate;\n  } else {\n    return current;\n  }\n};\n\nexports.DDB = function(cost, salvage, life, period, factor) {\n  // Initialize factor\n  factor = (factor === undefined) ? 2 : factor;\n\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  period = utils.parseNumber(period);\n  factor = utils.parseNumber(factor);\n  if (utils.anyIsError(cost, salvage, life, period, factor)) {\n    return error.value;\n  }\n\n  // Return error if any of the parameters is negative or if factor is null\n  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {\n    return error.num;\n  }\n\n  // Return error if period is greater than life\n  if (period > life) {\n    return error.num;\n  }\n\n  // Return 0 (zero) if salvage is greater than or equal to cost\n  if (salvage >= cost) {\n    return 0;\n  }\n\n  // Compute depreciation\n  var total = 0;\n  var current = 0;\n  for (var i = 1; i <= period; i++) {\n    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));\n    total += current;\n  }\n\n  // Return depreciation\n  return current;\n};\n\n// TODO\nexports.DISC = function() {\n  throw new Error('DISC is not implemented');\n};\n\nexports.DOLLARDE = function(dollar, fraction) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  dollar = utils.parseNumber(dollar);\n  fraction = utils.parseNumber(fraction);\n  if (utils.anyIsError(dollar, fraction)) {\n    return error.value;\n  }\n\n  // Return error if fraction is negative\n  if (fraction < 0) {\n    return error.num;\n  }\n\n  // Return error if fraction is greater than or equal to 0 and less than 1\n  if (fraction >= 0 && fraction < 1) {\n    return error.div0;\n  }\n\n  // Truncate fraction if it is not an integer\n  fraction = parseInt(fraction, 10);\n\n  // Compute integer part\n  var result = parseInt(dollar, 10);\n\n  // Add decimal part\n  result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;\n\n  // Round result\n  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);\n  result = Math.round(result * power) / power;\n\n  // Return converted dollar price\n  return result;\n};\n\nexports.DOLLARFR = function(dollar, fraction) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  dollar = utils.parseNumber(dollar);\n  fraction = utils.parseNumber(fraction);\n  if (utils.anyIsError(dollar, fraction)) {\n    return error.value;\n  }\n\n  // Return error if fraction is negative\n  if (fraction < 0) {\n    return error.num;\n  }\n\n  // Return error if fraction is greater than or equal to 0 and less than 1\n  if (fraction >= 0 && fraction < 1) {\n    return error.div0;\n  }\n\n  // Truncate fraction if it is not an integer\n  fraction = parseInt(fraction, 10);\n\n  // Compute integer part\n  var result = parseInt(dollar, 10);\n\n  // Add decimal part\n  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;\n\n  // Return converted dollar price\n  return result;\n};\n\n// TODO\nexports.DURATION = function() {\n  throw new Error('DURATION is not implemented');\n};\n\nexports.EFFECT = function(rate, periods) {\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  if (utils.anyIsError(rate, periods)) {\n    return error.value;\n  }\n\n  // Return error if rate <=0 or periods < 1\n  if (rate <= 0 || periods < 1) {\n    return error.num;\n  }\n\n  // Truncate periods if it is not an integer\n  periods = parseInt(periods, 10);\n\n  // Return effective annual interest rate\n  return Math.pow(1 + rate / periods, periods) - 1;\n};\n\nexports.FV = function(rate, periods, payment, value, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  value = value || 0;\n  type = type || 0;\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  payment = utils.parseNumber(payment);\n  value = utils.parseNumber(value);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, payment, value, type)) {\n    return error.value;\n  }\n\n  // Return future value\n  var result;\n  if (rate === 0) {\n    result = value + payment * periods;\n  } else {\n    var term = Math.pow(1 + rate, periods);\n    if (type === 1) {\n      result = value * term + payment * (1 + rate) * (term - 1) / rate;\n    } else {\n      result = value * term + payment * (term - 1) / rate;\n    }\n  }\n  return -result;\n};\n\nexports.FVSCHEDULE = function(principal, schedule) {\n  principal = utils.parseNumber(principal);\n  schedule = utils.parseNumberArray(utils.flatten(schedule));\n  if (utils.anyIsError(principal, schedule)) {\n    return error.value;\n  }\n\n  var n = schedule.length;\n  var future = principal;\n\n  // Apply all interests in schedule\n  for (var i = 0; i < n; i++) {\n    // Apply scheduled interest\n    future *= 1 + schedule[i];\n  }\n\n  // Return future value\n  return future;\n};\n\n// TODO\nexports.INTRATE = function() {\n  throw new Error('INTRATE is not implemented');\n};\n\nexports.IPMT = function(rate, period, periods, present, future, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  future = future || 0;\n  type = type || 0;\n\n  rate = utils.parseNumber(rate);\n  period = utils.parseNumber(period);\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, period, periods, present, future, type)) {\n    return error.value;\n  }\n\n  // Compute payment\n  var payment = exports.PMT(rate, periods, present, future, type);\n\n  // Compute interest\n  var interest;\n  if (period === 1) {\n    if (type === 1) {\n      interest = 0;\n    } else {\n      interest = -present;\n    }\n  } else {\n    if (type === 1) {\n      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;\n    } else {\n      interest = exports.FV(rate, period - 1, payment, present, 0);\n    }\n  }\n\n  // Return interest\n  return interest * rate;\n};\n\nexports.IRR = function(values, guess) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  guess = guess || 0;\n\n  values = utils.parseNumberArray(utils.flatten(values));\n  guess = utils.parseNumber(guess);\n  if (utils.anyIsError(values, guess)) {\n    return error.value;\n  }\n\n  // Calculates the resulting amount\n  var irrResult = function(values, dates, rate) {\n    var r = rate + 1;\n    var result = values[0];\n    for (var i = 1; i < values.length; i++) {\n      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);\n    }\n    return result;\n  };\n\n  // Calculates the first derivation\n  var irrResultDeriv = function(values, dates, rate) {\n    var r = rate + 1;\n    var result = 0;\n    for (var i = 1; i < values.length; i++) {\n      var frac = (dates[i] - dates[0]) / 365;\n      result -= frac * values[i] / Math.pow(r, frac + 1);\n    }\n    return result;\n  };\n\n  // Initialize dates and check that values contains at least one positive value and one negative value\n  var dates = [];\n  var positive = false;\n  var negative = false;\n  for (var i = 0; i < values.length; i++) {\n    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;\n    if (values[i] > 0) {\n      positive = true;\n    }\n    if (values[i] < 0) {\n      negative = true;\n    }\n  }\n\n  // Return error if values does not contain at least one positive value and one negative value\n  if (!positive || !negative) {\n    return error.num;\n  }\n\n  // Initialize guess and resultRate\n  guess = (guess === undefined) ? 0.1 : guess;\n  var resultRate = guess;\n\n  // Set maximum epsilon for end of iteration\n  var epsMax = 1e-10;\n\n  // Implement Newton's method\n  var newRate, epsRate, resultValue;\n  var contLoop = true;\n  do {\n    resultValue = irrResult(values, dates, resultRate);\n    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);\n    epsRate = Math.abs(newRate - resultRate);\n    resultRate = newRate;\n    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);\n  } while (contLoop);\n\n  // Return internal rate of return\n  return resultRate;\n};\n\nexports.ISPMT = function(rate, period, periods, value) {\n  rate = utils.parseNumber(rate);\n  period = utils.parseNumber(period);\n  periods = utils.parseNumber(periods);\n  value = utils.parseNumber(value);\n  if (utils.anyIsError(rate, period, periods, value)) {\n    return error.value;\n  }\n\n  // Return interest\n  return value * rate * (period / periods - 1);\n};\n\n// TODO\nexports.MDURATION = function() {\n  throw new Error('MDURATION is not implemented');\n};\n\nexports.MIRR = function(values, finance_rate, reinvest_rate) {\n  values = utils.parseNumberArray(utils.flatten(values));\n  finance_rate = utils.parseNumber(finance_rate);\n  reinvest_rate = utils.parseNumber(reinvest_rate);\n  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {\n    return error.value;\n  }\n\n  // Initialize number of values\n  var n = values.length;\n\n  // Lookup payments (negative values) and incomes (positive values)\n  var payments = [];\n  var incomes = [];\n  for (var i = 0; i < n; i++) {\n    if (values[i] < 0) {\n      payments.push(values[i]);\n    } else {\n      incomes.push(values[i]);\n    }\n  }\n\n  // Return modified internal rate of return\n  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);\n  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);\n  return Math.pow(num / den, 1 / (n - 1)) - 1;\n};\n\nexports.NOMINAL = function(rate, periods) {\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  if (utils.anyIsError(rate, periods)) {\n    return error.value;\n  }\n\n  // Return error if rate <=0 or periods < 1\n  if (rate <= 0 || periods < 1) {\n    return error.num;\n  }\n\n  // Truncate periods if it is not an integer\n  periods = parseInt(periods, 10);\n\n  // Return nominal annual interest rate\n  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;\n};\n\nexports.NPER = function(rate, payment, present, future, type) {\n  type = (type === undefined) ? 0 : type;\n  future = (future === undefined) ? 0 : future;\n\n  rate = utils.parseNumber(rate);\n  payment = utils.parseNumber(payment);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, payment, present, future, type)) {\n    return error.value;\n  }\n\n  // Return number of periods\n  var num = payment * (1 + rate * type) - future * rate;\n  var den = (present * rate + payment * (1 + rate * type));\n  return Math.log(num / den) / Math.log(1 + rate);\n};\n\nexports.NPV = function() {\n  var args = utils.parseNumberArray(utils.flatten(arguments));\n  if (args instanceof Error) {\n    return args;\n  }\n\n  // Lookup rate\n  var rate = args[0];\n\n  // Initialize net present value\n  var value = 0;\n\n  // Loop on all values\n  for (var j = 1; j < args.length; j++) {\n    value += args[j] / Math.pow(1 + rate, j);\n  }\n\n  // Return net present value\n  return value;\n};\n\n// TODO\nexports.ODDFPRICE = function() {\n  throw new Error('ODDFPRICE is not implemented');\n};\n\n// TODO\nexports.ODDFYIELD = function() {\n  throw new Error('ODDFYIELD is not implemented');\n};\n\n// TODO\nexports.ODDLPRICE = function() {\n  throw new Error('ODDLPRICE is not implemented');\n};\n\n// TODO\nexports.ODDLYIELD = function() {\n  throw new Error('ODDLYIELD is not implemented');\n};\n\nexports.PDURATION = function(rate, present, future) {\n  rate = utils.parseNumber(rate);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  if (utils.anyIsError(rate, present, future)) {\n    return error.value;\n  }\n\n  // Return error if rate <=0\n  if (rate <= 0) {\n    return error.num;\n  }\n\n  // Return number of periods\n  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);\n};\n\nexports.PMT = function(rate, periods, present, future, type) {\n  // Credits: algorithm inspired by Apache OpenOffice\n\n  future = future || 0;\n  type = type || 0;\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, present, future, type)) {\n    return error.value;\n  }\n\n  // Return payment\n  var result;\n  if (rate === 0) {\n    result = (present + future) / periods;\n  } else {\n    var term = Math.pow(1 + rate, periods);\n    if (type === 1) {\n      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);\n    } else {\n      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);\n    }\n  }\n  return -result;\n};\n\nexports.PPMT = function(rate, period, periods, present, future, type) {\n  future = future || 0;\n  type = type || 0;\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, present, future, type)) {\n    return error.value;\n  }\n\n  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);\n};\n\n// TODO\nexports.PRICE = function() {\n  throw new Error('PRICE is not implemented');\n};\n\n// TODO\nexports.PRICEDISC = function() {\n  throw new Error('PRICEDISC is not implemented');\n};\n\n// TODO\nexports.PRICEMAT = function() {\n  throw new Error('PRICEMAT is not implemented');\n};\n\nexports.PV = function(rate, periods, payment, future, type) {\n  future = future || 0;\n  type = type || 0;\n\n  rate = utils.parseNumber(rate);\n  periods = utils.parseNumber(periods);\n  payment = utils.parseNumber(payment);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  if (utils.anyIsError(rate, periods, payment, future, type)) {\n    return error.value;\n  }\n\n  // Return present value\n  if (rate === 0) {\n    return -payment * periods - future;\n  } else {\n    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);\n  }\n};\n\nexports.RATE = function(periods, payment, present, future, type, guess) {\n  // Credits: rabugento\n\n  guess = (guess === undefined) ? 0.01 : guess;\n  future = (future === undefined) ? 0 : future;\n  type = (type === undefined) ? 0 : type;\n\n  periods = utils.parseNumber(periods);\n  payment = utils.parseNumber(payment);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  type = utils.parseNumber(type);\n  guess = utils.parseNumber(guess);\n  if (utils.anyIsError(periods, payment, present, future, type, guess)) {\n    return error.value;\n  }\n\n  // Set maximum epsilon for end of iteration\n  var epsMax = 1e-10;\n\n  // Set maximum number of iterations\n  var iterMax = 50;\n\n  // Implement Newton's method\n  var y, y0, y1, x0, x1 = 0,\n    f = 0,\n    i = 0;\n  var rate = guess;\n  if (Math.abs(rate) < epsMax) {\n    y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\n  } else {\n    f = Math.exp(periods * Math.log(1 + rate));\n    y = present * f + payment * (1 / rate + type) * (f - 1) + future;\n  }\n  y0 = present + payment * periods + future;\n  y1 = present * f + payment * (1 / rate + type) * (f - 1) + future;\n  i = x0 = 0;\n  x1 = rate;\n  while ((Math.abs(y0 - y1) > epsMax) && (i < iterMax)) {\n    rate = (y1 * x0 - y0 * x1) / (y1 - y0);\n    x0 = x1;\n    x1 = rate;\n    if (Math.abs(rate) < epsMax) {\n      y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\n    } else {\n      f = Math.exp(periods * Math.log(1 + rate));\n      y = present * f + payment * (1 / rate + type) * (f - 1) + future;\n    }\n    y0 = y1;\n    y1 = y;\n    ++i;\n  }\n  return rate;\n};\n\n// TODO\nexports.RECEIVED = function() {\n  throw new Error('RECEIVED is not implemented');\n};\n\nexports.RRI = function(periods, present, future) {\n  periods = utils.parseNumber(periods);\n  present = utils.parseNumber(present);\n  future = utils.parseNumber(future);\n  if (utils.anyIsError(periods, present, future)) {\n    return error.value;\n  }\n\n  // Return error if periods or present is equal to 0 (zero)\n  if (periods === 0 || present === 0) {\n    return error.num;\n  }\n\n  // Return equivalent interest rate\n  return Math.pow(future / present, 1 / periods) - 1;\n};\n\nexports.SLN = function(cost, salvage, life) {\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  if (utils.anyIsError(cost, salvage, life)) {\n    return error.value;\n  }\n\n  // Return error if life equal to 0 (zero)\n  if (life === 0) {\n    return error.num;\n  }\n\n  // Return straight-line depreciation\n  return (cost - salvage) / life;\n};\n\nexports.SYD = function(cost, salvage, life, period) {\n  // Return error if any of the parameters is not a number\n  cost = utils.parseNumber(cost);\n  salvage = utils.parseNumber(salvage);\n  life = utils.parseNumber(life);\n  period = utils.parseNumber(period);\n  if (utils.anyIsError(cost, salvage, life, period)) {\n    return error.value;\n  }\n\n  // Return error if life equal to 0 (zero)\n  if (life === 0) {\n    return error.num;\n  }\n\n  // Return error if period is lower than 1 or greater than life\n  if (period < 1 || period > life) {\n    return error.num;\n  }\n\n  // Truncate period if it is not an integer\n  period = parseInt(period, 10);\n\n  // Return straight-line depreciation\n  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));\n};\n\nexports.TBILLEQ = function(settlement, maturity, discount) {\n  settlement = utils.parseDate(settlement);\n  maturity = utils.parseDate(maturity);\n  discount = utils.parseNumber(discount);\n  if (utils.anyIsError(settlement, maturity, discount)) {\n    return error.value;\n  }\n\n  // Return error if discount is lower than or equal to zero\n  if (discount <= 0) {\n    return error.num;\n  }\n\n  // Return error if settlement is greater than maturity\n  if (settlement > maturity) {\n    return error.num;\n  }\n\n  // Return error if maturity is more than one year after settlement\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\n    return error.num;\n  }\n\n  // Return bond-equivalent yield\n  return (365 * discount) / (360 - discount * dateTime.DAYS360(settlement, maturity, false));\n};\n\nexports.TBILLPRICE = function(settlement, maturity, discount) {\n  settlement = utils.parseDate(settlement);\n  maturity = utils.parseDate(maturity);\n  discount = utils.parseNumber(discount);\n  if (utils.anyIsError(settlement, maturity, discount)) {\n    return error.value;\n  }\n\n  // Return error if discount is lower than or equal to zero\n  if (discount <= 0) {\n    return error.num;\n  }\n\n  // Return error if settlement is greater than maturity\n  if (settlement > maturity) {\n    return error.num;\n  }\n\n  // Return error if maturity is more than one year after settlement\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\n    return error.num;\n  }\n\n  // Return bond-equivalent yield\n  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);\n};\n\nexports.TBILLYIELD = function(settlement, maturity, price) {\n  settlement = utils.parseDate(settlement);\n  maturity = utils.parseDate(maturity);\n  price = utils.parseNumber(price);\n  if (utils.anyIsError(settlement, maturity, price)) {\n    return error.value;\n  }\n\n  // Return error if price is lower than or equal to zero\n  if (price <= 0) {\n    return error.num;\n  }\n\n  // Return error if settlement is greater than maturity\n  if (settlement > maturity) {\n    return error.num;\n  }\n\n  // Return error if maturity is more than one year after settlement\n  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {\n    return error.num;\n  }\n\n  // Return bond-equivalent yield\n  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));\n};\n\n// TODO\nexports.VDB = function() {\n  throw new Error('VDB is not implemented');\n};\n\n// TODO needs better support for date\n// exports.XIRR = function(values, dates, guess) {\n//   // Credits: algorithm inspired by Apache OpenOffice\n//\n//   values = utils.parseNumberArray(utils.flatten(values));\n//   dates = utils.parseDateArray(utils.flatten(dates));\n//   guess = utils.parseNumber(guess);\n//\n//   if (utils.anyIsError(values, dates, guess)) {\n//     return error.value;\n//   }\n//\n//   // Calculates the resulting amount\n//   var irrResult = function(values, dates, rate) {\n//     var r = rate + 1;\n//     var result = values[0];\n//     for (var i = 1; i < values.length; i++) {\n//       result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);\n//     }\n//     return result;\n//   };\n//\n//   // Calculates the first derivation\n//   var irrResultDeriv = function(values, dates, rate) {\n//     var r = rate + 1;\n//     var result = 0;\n//     for (var i = 1; i < values.length; i++) {\n//       var frac = dateTime.DAYS(dates[i], dates[0]) / 365;\n//       result -= frac * values[i] / Math.pow(r, frac + 1);\n//     }\n//     return result;\n//   };\n//\n//   // Check that values contains at least one positive value and one negative value\n//   var positive = false;\n//   var negative = false;\n//   for (var i = 0; i < values.length; i++) {\n//     if (values[i] > 0) {\n//       positive = true;\n//     }\n//     if (values[i] < 0) {\n//       negative = true;\n//     }\n//   }\n//\n//   // Return error if values does not contain at least one positive value and one negative value\n//   if (!positive || !negative) {\n//     return error.num;\n//   }\n//\n//   // Initialize guess and resultRate\n//   guess = guess || 0.1;\n//   var resultRate = guess;\n//\n//   // Set maximum epsilon for end of iteration\n//   var epsMax = 1e-10;\n//\n//   // Implement Newton's method\n//   var newRate, epsRate, resultValue;\n//   var contLoop = true;\n//   do {\n//     resultValue = irrResult(values, dates, resultRate);\n//     newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);\n//     epsRate = Math.abs(newRate - resultRate);\n//     resultRate = newRate;\n//     contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);\n//   } while (contLoop);\n//\n//   // Return internal rate of return\n//   return resultRate;\n// };\n\nexports.XNPV = function(rate, values, dates) {\n  rate = utils.parseNumber(rate);\n  values = utils.parseNumberArray(utils.flatten(values));\n  dates = utils.parseDateArray(utils.flatten(dates));\n  if (utils.anyIsError(rate, values, dates)) {\n    return error.value;\n  }\n\n  var result = 0;\n  for (var i = 0; i < values.length; i++) {\n    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);\n  }\n  return result;\n};\n\n// TODO\nexports.YIELD = function() {\n  throw new Error('YIELD is not implemented');\n};\n\n// TODO\nexports.YIELDDISC = function() {\n  throw new Error('YIELDDISC is not implemented');\n};\n\n// TODO\nexports.YIELDMAT = function() {\n  throw new Error('YIELDMAT is not implemented');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}