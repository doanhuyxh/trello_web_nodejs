{"ast":null,"code":"var defaultOperator = '=';\nvar validSymbols = ['>', '>=', '<', '<=', '=', '<>'];\nvar TOKEN_TYPE_OPERATOR = 'operator';\nvar TOKEN_TYPE_LITERAL = 'literal';\nvar SUPPORTED_TOKENS = [TOKEN_TYPE_OPERATOR, TOKEN_TYPE_LITERAL];\nexports.TOKEN_TYPE_OPERATOR = TOKEN_TYPE_OPERATOR;\nexports.TOKEN_TYPE_LITERAL = TOKEN_TYPE_LITERAL;\n\n/**\n * Create token which describe passed symbol/value.\n *\n * @param {String} value Value/Symbol to describe.\n * @param {String} type Type of the token 'operator' or 'literal'.\n * @return {Object}\n */\nfunction createToken(value, type) {\n  if (SUPPORTED_TOKENS.indexOf(type) === -1) {\n    throw new Error('Unsupported token type: ' + type);\n  }\n  return {\n    value: value,\n    type: type\n  };\n}\n\n/**\n * Tries to cast numeric values to their type passed as a string.\n *\n * @param {*} value\n * @return {*}\n */\nfunction castValueToCorrectType(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  if (/^\\d+(\\.\\d+)?$/.test(value)) {\n    value = value.indexOf('.') === -1 ? parseInt(value, 10) : parseFloat(value);\n  }\n  return value;\n}\n\n/**\n * Generate stream of tokens from passed expression.\n *\n * @param {String} expression\n * @return {String[]}\n */\nfunction tokenizeExpression(expression) {\n  var expressionLength = expression.length;\n  var tokens = [];\n  var cursorIndex = 0;\n  var processedValue = '';\n  var processedSymbol = '';\n  while (cursorIndex < expressionLength) {\n    var char = expression.charAt(cursorIndex);\n    switch (char) {\n      case '>':\n      case '<':\n      case '=':\n        processedSymbol = processedSymbol + char;\n        if (processedValue.length > 0) {\n          tokens.push(processedValue);\n          processedValue = '';\n        }\n        break;\n      default:\n        if (processedSymbol.length > 0) {\n          tokens.push(processedSymbol);\n          processedSymbol = '';\n        }\n        processedValue = processedValue + char;\n        break;\n    }\n    cursorIndex++;\n  }\n  if (processedValue.length > 0) {\n    tokens.push(processedValue);\n  }\n  if (processedSymbol.length > 0) {\n    tokens.push(processedSymbol);\n  }\n  return tokens;\n}\n;\n\n/**\n * Analyze and convert tokens to an object which describes their meaning.\n *\n * @param {String[]} tokens\n * @return {Object[]}\n */\nfunction analyzeTokens(tokens) {\n  var literalValue = '';\n  var analyzedTokens = [];\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (i === 0 && validSymbols.indexOf(token) >= 0) {\n      analyzedTokens.push(createToken(token, TOKEN_TYPE_OPERATOR));\n    } else {\n      literalValue += token;\n    }\n  }\n  if (literalValue.length > 0) {\n    analyzedTokens.push(createToken(castValueToCorrectType(literalValue), TOKEN_TYPE_LITERAL));\n  }\n  if (analyzedTokens.length > 0 && analyzedTokens[0].type !== TOKEN_TYPE_OPERATOR) {\n    analyzedTokens.unshift(createToken(defaultOperator, TOKEN_TYPE_OPERATOR));\n  }\n  return analyzedTokens;\n}\n;\n\n/**\n * Compute/Evaluate an expression passed as an array of tokens.\n *\n * @param {Object[]} tokens\n * @return {Boolean}\n */\nfunction computeExpression(tokens) {\n  var values = [];\n  var operator;\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    switch (token.type) {\n      case TOKEN_TYPE_OPERATOR:\n        operator = token.value;\n        break;\n      case TOKEN_TYPE_LITERAL:\n        values.push(token.value);\n        break;\n    }\n  }\n  return evaluate(values, operator);\n}\n;\n\n/**\n * Evaluate values based on passed math operator.\n *\n * @param {*} values\n * @param {String} operator\n * @return {Boolean}\n */\nfunction evaluate(values, operator) {\n  var result = false;\n  switch (operator) {\n    case '>':\n      result = values[0] > values[1];\n      break;\n    case '>=':\n      result = values[0] >= values[1];\n      break;\n    case '<':\n      result = values[0] < values[1];\n      break;\n    case '<=':\n      result = values[0] <= values[1];\n      break;\n    case '=':\n      result = values[0] == values[1];\n      break;\n    case '<>':\n      result = values[0] != values[1];\n      break;\n  }\n  return result;\n}\nexports.parse = function (expression) {\n  return analyzeTokens(tokenizeExpression(expression));\n};\nexports.createToken = createToken;\nexports.compute = computeExpression;","map":{"version":3,"names":["defaultOperator","validSymbols","TOKEN_TYPE_OPERATOR","TOKEN_TYPE_LITERAL","SUPPORTED_TOKENS","exports","createToken","value","type","indexOf","Error","castValueToCorrectType","test","parseInt","parseFloat","tokenizeExpression","expression","expressionLength","length","tokens","cursorIndex","processedValue","processedSymbol","char","charAt","push","analyzeTokens","literalValue","analyzedTokens","i","token","unshift","computeExpression","values","operator","evaluate","result","parse","compute"],"sources":["D:/WebNodeJs/node18/trelo_project/front_end/node_modules/@handsontable/formulajs/lib/utils/criteria-eval.js"],"sourcesContent":["var defaultOperator = '=';\nvar validSymbols = ['>', '>=', '<', '<=', '=', '<>'];\nvar TOKEN_TYPE_OPERATOR = 'operator';\nvar TOKEN_TYPE_LITERAL = 'literal';\nvar SUPPORTED_TOKENS = [TOKEN_TYPE_OPERATOR, TOKEN_TYPE_LITERAL];\n\nexports.TOKEN_TYPE_OPERATOR = TOKEN_TYPE_OPERATOR;\nexports.TOKEN_TYPE_LITERAL = TOKEN_TYPE_LITERAL;\n\n/**\n * Create token which describe passed symbol/value.\n *\n * @param {String} value Value/Symbol to describe.\n * @param {String} type Type of the token 'operator' or 'literal'.\n * @return {Object}\n */\nfunction createToken(value, type) {\n  if (SUPPORTED_TOKENS.indexOf(type) === -1) {\n    throw new Error('Unsupported token type: ' + type);\n  }\n\n  return {\n    value: value,\n    type: type,\n  };\n}\n\n/**\n * Tries to cast numeric values to their type passed as a string.\n *\n * @param {*} value\n * @return {*}\n */\nfunction castValueToCorrectType(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  if (/^\\d+(\\.\\d+)?$/.test(value)) {\n    value = value.indexOf('.') === -1 ? parseInt(value, 10) : parseFloat(value);\n  }\n\n  return value;\n}\n\n/**\n * Generate stream of tokens from passed expression.\n *\n * @param {String} expression\n * @return {String[]}\n */\nfunction tokenizeExpression(expression) {\n  var expressionLength = expression.length;\n  var tokens = [];\n  var cursorIndex = 0;\n  var processedValue = '';\n  var processedSymbol = '';\n\n  while (cursorIndex < expressionLength) {\n    var char = expression.charAt(cursorIndex);\n\n    switch (char) {\n      case '>':\n      case '<':\n      case '=':\n        processedSymbol = processedSymbol + char;\n\n        if (processedValue.length > 0) {\n          tokens.push(processedValue);\n          processedValue = '';\n        }\n      break;\n      default:\n        if (processedSymbol.length > 0) {\n          tokens.push(processedSymbol);\n          processedSymbol = '';\n        }\n\n        processedValue = processedValue + char;\n      break;\n    }\n    cursorIndex++;\n  }\n\n  if (processedValue.length > 0) {\n    tokens.push(processedValue);\n  }\n  if (processedSymbol.length > 0) {\n    tokens.push(processedSymbol);\n  }\n\n  return tokens;\n};\n\n/**\n * Analyze and convert tokens to an object which describes their meaning.\n *\n * @param {String[]} tokens\n * @return {Object[]}\n */\nfunction analyzeTokens(tokens) {\n  var literalValue = '';\n  var analyzedTokens = [];\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (i === 0 && validSymbols.indexOf(token) >= 0) {\n      analyzedTokens.push(createToken(token, TOKEN_TYPE_OPERATOR));\n    } else {\n      literalValue += token;\n    }\n  }\n\n  if (literalValue.length > 0) {\n    analyzedTokens.push(createToken(castValueToCorrectType(literalValue), TOKEN_TYPE_LITERAL));\n  }\n\n  if (analyzedTokens.length > 0 && analyzedTokens[0].type !== TOKEN_TYPE_OPERATOR) {\n    analyzedTokens.unshift(createToken(defaultOperator, TOKEN_TYPE_OPERATOR));\n  }\n\n  return analyzedTokens;\n};\n\n/**\n * Compute/Evaluate an expression passed as an array of tokens.\n *\n * @param {Object[]} tokens\n * @return {Boolean}\n */\nfunction computeExpression(tokens) {\n  var values = [];\n  var operator;\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    switch (token.type) {\n      case TOKEN_TYPE_OPERATOR:\n        operator = token.value;\n      break;\n      case TOKEN_TYPE_LITERAL:\n        values.push(token.value);\n      break;\n    }\n  }\n\n  return evaluate(values, operator);\n};\n\n/**\n * Evaluate values based on passed math operator.\n *\n * @param {*} values\n * @param {String} operator\n * @return {Boolean}\n */\nfunction evaluate(values, operator) {\n  var result = false;\n\n  switch (operator) {\n    case '>':\n      result = values[0] > values[1];\n      break;\n    case '>=':\n      result = values[0] >= values[1];\n      break;\n    case '<':\n      result = values[0] < values[1];\n      break;\n    case '<=':\n      result = values[0] <= values[1];\n      break;\n    case '=':\n      result = values[0] == values[1];\n      break;\n    case '<>':\n      result = values[0] != values[1];\n      break;\n  }\n\n  return result;\n}\n\nexports.parse = function(expression) {\n  return analyzeTokens(tokenizeExpression(expression));\n};\nexports.createToken = createToken;\nexports.compute = computeExpression;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}