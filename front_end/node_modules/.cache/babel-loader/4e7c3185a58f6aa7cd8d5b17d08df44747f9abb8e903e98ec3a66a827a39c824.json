{"ast":null,"code":"import formulajs from '@handsontable/formulajs';\nimport SUPPORTED_FORMULAS from \"./../../supported-formulas.mjs\";\nimport { ERROR_NAME } from \"./../../error.mjs\";\nexport var SYMBOL = SUPPORTED_FORMULAS;\nexport default function func(symbol) {\n  return function __formulaFunction() {\n    symbol = symbol.toUpperCase();\n    var symbolParts = symbol.split('.');\n    var foundFormula = false;\n    var result;\n    if (symbolParts.length === 1) {\n      if (formulajs[symbolParts[0]]) {\n        foundFormula = true;\n        result = formulajs[symbolParts[0]].apply(formulajs, arguments);\n      }\n    } else {\n      var length = symbolParts.length;\n      var index = 0;\n      var nestedFormula = formulajs;\n      while (index < length) {\n        nestedFormula = nestedFormula[symbolParts[index]];\n        index++;\n        if (!nestedFormula) {\n          nestedFormula = null;\n          break;\n        }\n      }\n      if (nestedFormula) {\n        foundFormula = true;\n        result = nestedFormula.apply(void 0, arguments);\n      }\n    }\n    if (!foundFormula) {\n      throw Error(ERROR_NAME);\n    }\n    return result;\n  };\n}\nfunc.isFactory = true;\nfunc.SYMBOL = SYMBOL;","map":{"version":3,"names":["formulajs","SUPPORTED_FORMULAS","ERROR_NAME","SYMBOL","func","symbol","__formulaFunction","toUpperCase","symbolParts","split","foundFormula","result","length","apply","arguments","index","nestedFormula","Error","isFactory"],"sources":["D:/WebNodeJs/node18/trelo_project/front_end/node_modules/hot-formula-parser/evaluate-by-operator/operator/formula-function.mjs"],"sourcesContent":["import formulajs from '@handsontable/formulajs';\nimport SUPPORTED_FORMULAS from \"./../../supported-formulas.mjs\";\nimport { ERROR_NAME } from \"./../../error.mjs\";\nexport var SYMBOL = SUPPORTED_FORMULAS;\nexport default function func(symbol) {\n  return function __formulaFunction() {\n    symbol = symbol.toUpperCase();\n    var symbolParts = symbol.split('.');\n    var foundFormula = false;\n    var result;\n\n    if (symbolParts.length === 1) {\n      if (formulajs[symbolParts[0]]) {\n        foundFormula = true;\n        result = formulajs[symbolParts[0]].apply(formulajs, arguments);\n      }\n    } else {\n      var length = symbolParts.length;\n      var index = 0;\n      var nestedFormula = formulajs;\n\n      while (index < length) {\n        nestedFormula = nestedFormula[symbolParts[index]];\n        index++;\n\n        if (!nestedFormula) {\n          nestedFormula = null;\n          break;\n        }\n      }\n\n      if (nestedFormula) {\n        foundFormula = true;\n        result = nestedFormula.apply(void 0, arguments);\n      }\n    }\n\n    if (!foundFormula) {\n      throw Error(ERROR_NAME);\n    }\n\n    return result;\n  };\n}\nfunc.isFactory = true;\nfunc.SYMBOL = SYMBOL;"],"mappings":"AAAA,OAAOA,SAAS,MAAM,yBAAyB;AAC/C,OAAOC,kBAAkB,MAAM,gCAAgC;AAC/D,SAASC,UAAU,QAAQ,mBAAmB;AAC9C,OAAO,IAAIC,MAAM,GAAGF,kBAAkB;AACtC,eAAe,SAASG,IAAIA,CAACC,MAAM,EAAE;EACnC,OAAO,SAASC,iBAAiBA,CAAA,EAAG;IAClCD,MAAM,GAAGA,MAAM,CAACE,WAAW,CAAC,CAAC;IAC7B,IAAIC,WAAW,GAAGH,MAAM,CAACI,KAAK,CAAC,GAAG,CAAC;IACnC,IAAIC,YAAY,GAAG,KAAK;IACxB,IAAIC,MAAM;IAEV,IAAIH,WAAW,CAACI,MAAM,KAAK,CAAC,EAAE;MAC5B,IAAIZ,SAAS,CAACQ,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;QAC7BE,YAAY,GAAG,IAAI;QACnBC,MAAM,GAAGX,SAAS,CAACQ,WAAW,CAAC,CAAC,CAAC,CAAC,CAACK,KAAK,CAACb,SAAS,EAAEc,SAAS,CAAC;MAChE;IACF,CAAC,MAAM;MACL,IAAIF,MAAM,GAAGJ,WAAW,CAACI,MAAM;MAC/B,IAAIG,KAAK,GAAG,CAAC;MACb,IAAIC,aAAa,GAAGhB,SAAS;MAE7B,OAAOe,KAAK,GAAGH,MAAM,EAAE;QACrBI,aAAa,GAAGA,aAAa,CAACR,WAAW,CAACO,KAAK,CAAC,CAAC;QACjDA,KAAK,EAAE;QAEP,IAAI,CAACC,aAAa,EAAE;UAClBA,aAAa,GAAG,IAAI;UACpB;QACF;MACF;MAEA,IAAIA,aAAa,EAAE;QACjBN,YAAY,GAAG,IAAI;QACnBC,MAAM,GAAGK,aAAa,CAACH,KAAK,CAAC,KAAK,CAAC,EAAEC,SAAS,CAAC;MACjD;IACF;IAEA,IAAI,CAACJ,YAAY,EAAE;MACjB,MAAMO,KAAK,CAACf,UAAU,CAAC;IACzB;IAEA,OAAOS,MAAM;EACf,CAAC;AACH;AACAP,IAAI,CAACc,SAAS,GAAG,IAAI;AACrBd,IAAI,CAACD,MAAM,GAAGA,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}